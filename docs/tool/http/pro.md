---
title: HTTP 进阶
date: 2021-05-06 21:59:12
# permalink: false # 6654b1/
categories: 
  - http
tags: 
  - http
permalink: false # 07f043/
---



# HTTP 进阶

## HTTP/2

Q：为什么 HTTP/2 不像之前的“1.0”“1.1”那样叫“2.0”呢？
> HTTP/2 工作组给出了解释：他们认为以前的“1.0”“1.1”造成了很多的混乱和误解，让人在实际的使用中难以区分差异，所以就决定 HTTP 协议不再使用小版本号（minor version），只使用大版本号（major version），从今往后 HTTP 协议不会出现 HTTP/2.0、2.1，只会有“HTTP/2”“HTTP/3”……

> 这样就可以明确无误地辨别出协议版本的“跃进程度”，让协议在一段较长的时期内保持稳定，每当发布新版本的 HTTP 协议都会有本质的不同，绝不会有“零敲碎打”的小改良。


### 兼容 HTTP/1
因为必须要保持功能上的兼容，所以 HTTP/2 把 HTTP 分解成了**语义**和**语法**两个部分，“语义”层不做改动，与 HTTP/1 完全一致（即 RFC7231）。比如请求方法、URI、状态码、头字段等概念都保留不变，这样就消除了再学习的成本，基于 HTTP 的上层应用也不需要做任何修改，可以无缝转换到 HTTP/2。

HTTP/2 没有在 URI 里引入新的协议名，仍然用“http”表示明文协议，用“https”表示加密协议；这样可以让浏览器或者服务器去自动升级或降级协议，免去了选择的麻烦，让用户在上网的时候都意识不到协议的切换，实现平滑过渡。


### HTTP/2的改造
在“语义”保持稳定之后，HTTP/2 在“语法”层做了“天翻地覆”的改造，完全变更了 HTTP 报文的传输格式：

- **头部压缩**
> 由于报文 Header 一般会携带“User Agent”“Cookie”“Accept”“Server”等许多固定的头字段，多达几百字节甚至上千字节，但 Body 却经常只有几十字节（比如 GET 请求、204/301/304 响应），成千上万的请求响应报文里有很多字段值都是重复的，非常浪费，“长尾效应”导致大量带宽消耗在了这些冗余度极高的数据上。

HTTP/2 并没有使用传统的压缩算法，而是开发了专门的“HPACK”算法，在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，还釆用哈夫曼编码来压缩整数和字符串，可以达到 50%~90% 的高压缩率。

- **二进制格式**
> HTTP/1 里是纯文本形式的报文，HTTP/2 不再使用肉眼可见的 ASCII 码，而是向下层的 TCP/IP 协议“靠拢”，全面采用二进制格式。

这样大大方便了计算机的解析，原来使用纯文本的时候容易出现多义性，比如大小写、空白字符、回车换行、多字少字等等，程序在处理时必须用复杂的状态机，效率低，还麻烦。

二进制里只有“0”和“1”，可以严格规定字段大小、顺序、标志位等格式，“对就是对，错就是错”，解析起来没有歧义，实现简单，而且体积小、速度快，做到“内部提效”。

它把 TCP 协议的部分特性挪到了应用层，把原来的“Header+Body”的消息“打散”为数个小片的**二进制“帧”**（Frame），用 **HEADERS帧存放头数据、DATA帧存放实体数据**。

<img class="zoom-custom-imgs" :src="$withBase('/images/https/pro101.png')" width="auto"/>

> HTTP/2 数据分帧后“Header+Body”的报文结构就完全消失了，协议看到的只是一个个的“碎片”。


- **虚拟的“流”**
> 消息的“碎片”到达目的地后应该怎么组装起来呢？

HTTP/2 为此定义了一个**流**（Stream）的概念，它是**二进制帧的双向传输序列**，同一个消息往返的帧会分配一个唯一的流 ID。你可以把它想象成是一个虚拟的“数据流”，在里面流动的是一串有先后顺序的数据帧，这些数据帧按照次序组装起来就是 HTTP/1 里的请求报文和响应报文。

因为“流”是虚拟的，实际上并不存在，所以 HTTP/2 就可以在一个 TCP 连接上用“流”同时发送多个“碎片化”的消息，这就是常说的**多路复用**（ Multiplexing）——多个往返通信都复用一个连接来处理。
> 在“流”的层面上看，消息是一些有序的“帧”序列，而在“连接”的层面上看，消息却是乱序收发的“帧”。多个请求 / 响应之间没有了顺序关系，不需要排队等待，也就不会再出现“队头阻塞”问题，降低了延迟，大幅度提高了连接的利用率。

- 为了更好地利用连接，加大吞吐量，HTTP/2 还添加了一些控制帧来管理虚拟的“流”，实现了优先级和流量控制，这些特性也和 TCP 协议非常相似。

- HTTP/2 还在一定程度上改变了传统的“请求 - 应答”工作模式，服务器不再是完全被动地响应请求，也可以新建“流”主动向客户端发送消息。比如，在浏览器刚请求 HTML 的时候就提前把可能会用到的 JS、CSS 文件发给客户端，减少等待的延迟，这被称为**服务器推送**（Server Push，也叫 Cache Push）。

- **强化安全**

出于兼容的考虑，HTTP/2 延续了 HTTP/1 的“明文”特点，可以像以前一样使用明文传输数据，不强制使用加密通信，不过格式还是二进制，只是不需要解密。

为了区分“加密”和“明文”这两个不同的版本，HTTP/2 协议定义了两个字符串标识符：“h2”表示加密的 HTTP/2，“h2c”表示明文的 HTTP/2，多出的那个字母“c”的意思是“clear text”。

在 HTTP/2 标准制定的时候（2015 年）已经发现了很多 SSL/TLS 的弱点，而新的 TLS1.3 还未发布，所以加密版本的 HTTP/2 在安全方面做了强化，要求下层的通信协议必须是 TLS1.2 以上，还要支持前向安全和 SNI，并且把几百个弱密码套件列入了“黑名单”，比如 DES、RC4、CBC、SHA-1 都不能在 HTTP/2 里使用，相当于底层用的是“TLS1.25”。


- **协议栈**

下面的这张图对比了 HTTP/1、HTTPS 和 HTTP/2 的协议栈：

<img class="zoom-custom-imgs" :src="$withBase('/images/https/pro102.png')" width="auto"/>

虽然 HTTP/2 的底层实现很复杂，但它的“语义”还是简单的 HTTP/1，之前学习的知识不会过时，仍然能够用得上。



### HTTP/2流程

#### 连接前言
> 由于 HTTP/2“事实上”是基于 TLS，所以在正式收发数据之前，会有 TCP 握手和 TLS 握手。

TLS 握手成功之后，客户端必须要发送一个**连接前言**（connection preface），用来确认建立 HTTP/2 连接。

这个“连接前言”是标准的 HTTP/1 请求报文，使用纯文本的 ASCII 码格式，请求方法是特别注册的一个关键字“PRI”，全文只有 24 个字节：
``` shell
PRI * HTTP/2.0\r\n\r\nSM\r\n\r\nb
```
> 只要服务器收到这个，就知道客户端在 TLS 上想要的是 HTTP/2 协议，而不是其他别的协议，后面就会都使用 HTTP/2 的数据格式。


#### 头部压缩
> 确立了连接之后，HTTP/2 就开始准备请求报文。

因为语义上它与 HTTP/1 兼容，所以报文还是由“Header+Body”构成的，但在请求发送前，必须要用 **HPACK** 算法来压缩头部数据。
> “HPACK”算法是专门为压缩 HTTP 头部定制的算法，与 gzip、zlib 等压缩算法不同，它是一个“有状态”的算法，需要客户端和服务器各自维护一份“索引表”，也可以说是“字典”（这有点类似 brotli），压缩和解压缩就是查表和更新表的操作。

为了方便管理和压缩，HTTP/2 废除了原有的起始行概念，把起始行里面的请求方法、URI、状态码等统一转换成了头字段的形式，并且给这些“不是头字段的头字段”起了个特别的名字——**伪头字段**（pseudo-header fields）。而起始行里的版本号和错误原因短语因为没什么大用，顺便也给废除了。

为了与“真头字段”区分开来，这些“伪头字段”会在名字前加一个“:”，比如“:authority” “:method” “:status”，分别表示的是域名、请求方法和状态码。

- 静态表

现在 HTTP 报文头就简单了，全都是“Key-Value”形式的字段，于是 HTTP/2 就为一些最常用的头字段定义了一个只读的**静态表**（Static Table）。

<img class="zoom-custom-imgs" :src="$withBase('/images/https/pro103.png')" width="auto"/>

> 这个表格列出了“静态表”的一部分，这样只要查表就可以知道字段名和对应的值，比如数字“2”代表“GET”，数字“8”代表状态码 200。

- 动态表
> **动态表**（Dynamic Table）添加在静态表后面，结构相同，但会在编码解码的时候随时更新。

比如说，第一次发送请求时的“user-agent”字段长是一百多个字节，用哈夫曼压缩编码发送之后，客户端和服务器都更新自己的动态表，添加一个新的索引号，那么下一次发送的时候就不用再重复发那么多字节了，只要用一个字节发送编号就好。

随着在 HTTP/2 连接上发送的报文越来越多，两边的“字典”也会越来越丰富，最终每次的头部字段都会变成一两个字节的代码，原来上千字节的头用几十个字节就可以表示了，压缩效果比 gzip 要好得多。


#### 二进制帧
> 头部数据压缩之后，HTTP/2 就要把报文拆成二进制的帧准备发送。

HTTP/2 的帧结构有点类似 TCP 的段或者 TLS 里的记录，但报头很小，只有 9 字节，非常地节省。二进制的格式也保证了不会有歧义，而且使用位运算能够非常简单高效地解析。

<img class="zoom-custom-imgs" :src="$withBase('/images/https/pro104.png')" width="auto"/>

- 帧开头是 3 个字节的**长度**（但不包括头的 9 个字节），默认上限是 2^14，最大是 2^24，也就是说 HTTP/2 的帧通常不超过 16K，最大是 16M。
- 长度后面的一个字节是**帧类型**，大致可以分成**数据帧**和**控制帧**两类，HEADERS 帧和 DATA 帧属于数据帧，存放的是 HTTP 报文，而 SETTINGS、PING、PRIORITY 等则是用来管理流的控制帧。
- 第 5 个字节是非常重要的**帧标志**信息，可以保存 8 个标志位，携带简单的控制信息。
- 报文头里最后 4 个字节是**流标识符**，也就是帧所属的“流”，接收方使用它就可以从乱序的帧里识别出具有相同流 ID 的帧序列，按顺序组装起来就实现了虚拟的“流”。


#### 流与多路复用
> 弄清楚了帧结构后我们就来看 HTTP/2 的流与多路复用，它是 HTTP/2 最核心的部分。

在 HTTP/2 连接上，虽然帧是乱序收发的，但只要它们都拥有相同的流 ID，就都属于一个流，而且在这个流里帧不是无序的，而是有着严格的先后顺序。

在概念上，一个 HTTP/2 的流就等同于一个 HTTP/1 里的“请求 - 应答”。在 HTTP/1 里一个“请求 - 响应”报文来回是一次 HTTP 通信，在 HTTP/2 里一个流也承载了相同的功能。

#### 流状态转换
- 最开始的时候流都是“空闲”（idle）状态，也就是“不存在”，可以理解成是待分配的“号段资源”。
- 当客户端发送 HEADERS 帧后，有了流 ID，流就进入了“打开”状态，两端都可以收发数据，然后客户端发送一个带“END_STREAM”标志位的帧，流就进入了“半关闭”状态。
- 这个“半关闭”状态很重要，意味着客户端的请求数据已经发送完了，需要接受响应数据，而服务器端也知道请求数据接收完毕，之后就要内部处理，再发送响应数据。
- 响应数据发完了之后，也要带上“END_STREAM”标志位，表示数据发送完毕，这样流两端就都进入了“关闭”状态，流就结束了。

流 ID 不能重用，所以流的生命周期就是 HTTP/1 里的一次完整的“请求 - 应答”，流关闭就是一次通信结束。

> 参考：[HTTP/2内核剖析](https://time.geekbang.org/column/article/113481)


### 总结

::: tip HTTP/2的优点
1. 完全保持了与 HTTP/1 的兼容
2. 在安全上，HTTP/2 对 HTTPS 在各方面都做了强化：
    - 下层的 TLS 至少是 1.2，而且只能使用前向安全的密码套件（即 ECDHE），这同时也就默认实现了“TLS False Start”，支持 1-RTT 握手，所以不需要再加额外的配置就可以自动实现 HTTPS 加速。
3. HTTP/2 的头部压缩、多路复用、流优先级、服务器推送等手段节约了网络带宽，解决了队头阻塞问题、延迟等问题
:::

::: warning HTTP/2的缺点
1. HTTP/2 在 TCP 级别还是存在“队头阻塞”的问题。所以，如果网络连接质量差，发生丢包，那么 TCP 会等待重传，传输速度就会降低。
2. 在移动网络中发生 IP 地址切换的时候，下层的 TCP 必须重新建连，要再次“握手”，经历“慢启动”，而且之前连接里积累的 HPACK 字典也都消失了，必须重头开始计算，导致带宽浪费和时延。
3. HTTP/2 对一个域名只开一个连接，所以一旦这个连接出问题，那么整个网站的体验也就变差了。
:::


## HTTP/3
> HTTP/2 做出的许多努力，比如头部压缩、二进制分帧、虚拟的“流”与多路复用，“基本上”解决了“队头阻塞”这个问题；但这些手段都是在应用层里，而在下层，也就是 TCP 协议里，还是会发生“队头阻塞”。

Q：这是为什么呢？
> 从协议栈的角度来仔细看一下，在 HTTP/2 把多个“请求 - 响应”分解成流，交给 TCP 后，TCP 会再拆成更小的包依次发送（其实在 TCP 里应该叫 segment，也就是“段”）。在网络良好的情况下，包可以很快送达目的地。但如果网络质量比较差，像手机上网的时候，就有可能会丢包。而 TCP 为了保证可靠传输，有个特别的“丢包重传”机制，丢失的包必须要等待重新传输确认，其他的包即使已经收到了，也只能放在缓冲区里，上层的应用拿不出来，只能“干着急”。

由于这种“队头阻塞”是 TCP 协议固有的，所以 HTTP/2 即使设计出再多的“花样”也无法解决。

Google 在推 SPDY 的时候就已经意识到了这个问题，于是就又发明了一个新的“QUIC”协议，让 HTTP 跑在 QUIC 上而不是 TCP 上。

而这个“HTTP over QUIC”就是 HTTP 协议的下一个大版本，**HTTP/3**。它在 HTTP/2 的基础上又实现了质的飞跃，真正“完美”地解决了“队头阻塞”问题。

<img class="zoom-custom-imgs" :src="$withBase('/images/https/pro201.png')" width="auto"/>

从这张图里，你可以看到 HTTP/3 有一个关键的改变，那就是它把下层的 TCP“抽掉”了，换成了 UDP。因为 UDP 是无序的，包之间没有依赖关系，所以就从根本上解决了“队头阻塞”。


### QUIC 协议

UDP 是一个简单、不可靠的传输协议，只是对 IP 协议的一层很薄的包装，和 TCP 相比，它实际应用的较少。

不过正是因为它简单，不需要建连和断连，通信成本低，也就非常灵活、高效，“可塑性”很强。所以，QUIC 就选定了 UDP，在它之上把 TCP 的那一套连接管理、拥塞窗口、流量控制等“搬”了过来，“去其糟粕，取其精华”，打造出了一个全新的可靠传输协议，可以认为是**新时代的 TCP**。

QUIC 最早是由 Google 发明的，被称为 gQUIC。而当前正在由 IETF 标准化的 QUIC 被称为 iQUIC。两者的差异非常大，甚至比当年的 SPDY 与 HTTP/2 的差异还要大。

gQUIC 混合了 UDP、TLS、HTTP，是一个应用层的协议。而 IETF 则对 gQUIC 做了“清理”，把应用部分分离出来，形成了 HTTP/3，原来的 UDP 部分“下放”到了传输层，所以 iQUIC 有时候也叫“QUIC-transport”。


### QUIC 的特点

- QUIC 基于 UDP，而 UDP 是“无连接”的，根本就不需要“握手”和“挥手”，所以天生就要比 TCP 快。
- 就像 TCP 在 IP 的基础上实现了可靠传输一样，QUIC 也基于 UDP 实现了可靠传输，保证数据一定能够抵达目的地。
- 为了防止网络上的中间设备（Middle Box）识别协议的细节，QUIC 全面采用加密通信，可以很好地抵御窜改和“协议僵化”（ossification）。

### QUIC 内部细节

QUIC 的基本数据传输单位是**包**（packet）和**帧**（frame），一个包由多个帧组成，包面向的是“连接”，帧面向的是“流”。

QUIC 使用不透明的“连接 ID”来标记通信的两个端点，客户端和服务器可以自行选择一组 ID 来标记自己，这样就解除了 TCP 里连接对“IP 地址 + 端口”（即常说的四元组）的强绑定，支持“连接迁移”（Connection Migration）。


### HTTP/3 协议

因为 QUIC 本身就已经支持了加密、流和多路复用，所以 HTTP/3 的工作减轻了很多，把流控制都交给 QUIC 去做。调用的不再是 TLS 的安全接口，也不是 Socket API，而是专门的 QUIC 函数。不过这个“QUIC 函数”还没有形成标准，必须要绑定到某一个具体的实现库。

HTTP/3 里仍然使用流来发送“请求 - 响应”，但它自身不需要像 HTTP/2 那样再去定义流，而是直接使用 QUIC 的流，相当于做了一个“概念映射”。

头部压缩算法在 HTTP/3 里升级成了**QPACK**，使用方式上也做了改变。虽然也分成静态表和动态表，但在流上发送 HEADERS 帧时不能更新字段，只能引用，索引表的更新需要在专门的单向流上发送指令来管理，解决了 HPACK 的“队头阻塞”问题。

> 具体参考：[HTTP/3展望](https://time.geekbang.org/column/article/115564)



## Nginx
> 作为一个 Web 服务器，Nginx 的功能非常完善，完美支持 HTTP/1、HTTPS 和 HTTP/2，而且还在不断进步。当前的主线版本已经发展到了 1.17，正在进行 HTTP/3 的研发，或许将来就能在 Nginx 上跑 HTTP/3 了。


- **进程池**

Nginx 是个“轻量级”的 Web 服务器，它的 CPU、内存占用都非常少，同样的资源配置下就能够为更多的用户提供服务。
> 在 Nginx 之前，Web 服务器的工作模式大多是“Per-Process”或者“Per-Thread”，对每一个请求使用单独的进程或者线程处理。这就存在创建进程或线程的成本，还会有进程、线程“上下文切换”的额外开销。如果请求数量很多，CPU 就会在多个进程、线程之间切换时“疲于奔命”，平白地浪费了计算时间。

Nginx 则完全不同，“一反惯例”地没有使用多线程，而是使用了**进程池 + 单线程**的工作模式。

Nginx 在启动的时候会预先创建好固定数量的 worker 进程，在之后的运行过程中不会再 fork 出新进程，这就是**进程池**，而且可以自动把进程“绑定”到独立的 CPU 上，这样就完全消除了进程创建和切换的成本，能够充分利用多核 CPU 的计算能力。

在进程池之上，还有一个“master”进程，专门用来管理进程池。它的作用是用来监控进程，自动恢复发生异常的 worker，保持进程池的稳定和服务能力。

<img class="zoom-custom-imgs" :src="$withBase('/images/https/pro202.png')" width="auto"/>


- **I/O 多路复用**

> 多线程也有一些缺点，除了刚才说到的“上下文切换”成本，还有编程模型复杂、数据竞争、同步等问题。Nginx 就选择了单线程的方式，带来的好处就是开发简单，没有互斥锁的成本，减少系统消耗。

Nginx 利用了 Linux 内核里的**I/O 多路复用接口**：epoll。

Web 服务器从根本上来说是“I/O 密集型”而不是“CPU 密集型”，处理能力的关键在于网络收发而不是 CPU 计算（这里暂时不考虑 HTTPS 的加解密），而网络 I/O 会因为各式各样的原因不得不等待，比如数据还没到达、对端没有响应、缓冲区满发不出去等等。

这种情形就有点像是 HTTP 里的“队头阻塞”。对于一般的单线程来说 CPU 就会“停下来”，造成浪费。而多线程的解决思路有点类似“并发连接”，虽然有的线程可能阻塞，但由于多个线程并行，总体上看阻塞的情况就不会太严重了。

**Nginx 里使用的 epoll，就好像是 HTTP/2 里的“多路复用”技术**，它把多个 HTTP 请求处理打散成碎片，都“复用”到一个单线程里，不按照先来后到的顺序处理，而是只当连接上真正可读、可写的时候才处理，如果可能发生阻塞就立刻切换出去，处理其他的请求。

通过这种方式，Nginx 就完全消除了 I/O 阻塞，把 CPU 利用得“满满当当”，又因为网络收发并不会消耗太多 CPU 计算能力，也不需要切换进程、线程，所以整体的 CPU 负载是相当低的。
> epoll 还有一个特点，大量的连接管理工作都是在操作系统内核里做的，这就减轻了应用程序的负担，所以 Nginx 可以为每个连接只分配很小的内存维护状态，即使有几万、几十万的并发连接也只会消耗几百 M 内存，而其他的 Web 服务器这个时候早就“Memory not enough”了。


- **多阶段处理**

> 有了“进程池”和“I/O 多路复用”，Nginx 是如何处理 HTTP 请求的呢？

Nginx 在内部也采用的是**化整为零**的思路，把整个 Web 服务器分解成了多个“功能模块”，就好像是乐高积木，可以在配置文件里任意拼接搭建，从而实现了高度的灵活性和扩展性。

::: tip Nginx 的 HTTP 处理有四大类模块：
1. handler 模块：直接处理 HTTP 请求；
2. filter 模块：不直接处理请求，而是加工过滤响应报文；
3. upstream 模块：实现反向代理功能，转发请求到其他服务器；
4. balance 模块：实现反向代理时的负载均衡算法。
:::

Nginx 里的 handler 模块和 filter 模块就是按照“职责链”模式设计和组织的，HTTP 请求报文就是“原材料”，各种模块就是工厂里的工人，走完模块构成的“流水线”，出来的就是处理完成的响应报文。

> 参考：[Nginx：高性能的Web服务器](https://time.geekbang.org/column/article/117492)



## OpenResty

> Nginx 的服务管理思路延续了当时的流行做法，使用磁盘上的静态配置文件，所以每次修改后必须重启才能生效。这在业务频繁变动的时候是非常致命的（例如流行的微服务架构），特别是对于拥有成千上万台服务器的网站来说，仅仅增加或者删除一行配置就要分发、重启所有的机器，对运维是一个非常大的挑战，要耗费很多的时间和精力，成本很高，很不灵活，难以“随需应变”。

[OpenResty](http://openresty.org/cn/)，它是一个“更好更灵活的 Nginx”。它并不是一个全新的 Web 服务器，而是基于 Nginx，它利用了 Nginx 模块化、可扩展的特性，开发了一系列的增强模块，并把它们打包整合，形成了一个**一站式的 Web 开发平台**。

虽然 OpenResty 的核心是 Nginx，但它又超越了 Nginx，关键就在于其中的 ngx_lua 模块，把小巧灵活的 Lua 语言嵌入了 Nginx，可以用脚本的方式操作 Nginx 内部的进程、多路复用、阶段式处理等各种构件。

- **动态的 Lua**

> 刚才说了，OpenResty 里的一个关键模块是 ngx_lua，它为 Nginx 引入了脚本语言 Lua。

Lua 是一个比较“小众”的语言，虽然历史比较悠久，但名气却没有 PHP、Python、JavaScript 大，这主要与它的自身定位有关。

Lua 的设计目标是嵌入到其他应用程序里运行，为其他编程语言带来“脚本化”能力，所以它的“个头”比较小，功能集有限，不追求“大而全”，而是“小而美”，大多数时间都“隐匿”在其他应用程序的后面，是“无名英雄”。

因为 Nginx C 开发实在是太麻烦了，限制了 Nginx 的真正实力。而 Lua 作为“最快的脚本语言”恰好可以成为 Nginx 的完美搭档，既可以简化开发，性能上又不会有太多的损耗。
- 作为脚本语言，Lua 还有一个重要的**代码热加载**特性，不需要重启进程，就能够从磁盘、Redis 或者任何其他地方加载数据，随时替换内存里的代码片段。这就带来了**动态配置**，让 OpenResty 能够永不停机，在微秒、毫秒级别实现配置和业务逻辑的实时更新，比起 Nginx 秒级的重启是一个极大的进步。


- **高效率的 Lua**

OpenResty 能够高效运行的一大“秘技”是它的**同步非阻塞**编程范式。“同步非阻塞”本质上还是一种**多路复用**。

Nginx epoll 是操作系统级别的“多路复用”，运行在内核空间。而 OpenResty 的“同步非阻塞”则是基于 Lua 内建的“协程”，是应用程序级别的“多路复用”，运行在用户空间，所以它的资源消耗要更少。


- **阶段式处理**

和 Nginx 一样，OpenResty 也使用“流水线”来处理 HTTP 请求，底层的运行基础是 Nginx 的“阶段式处理”，但它又有自己的特色。

Nginx 的“流水线”是由一个个 C 模块组成的，只能在静态文件里配置，开发困难，配置麻烦（相对而言）。而 OpenResty 的“流水线”则是由一个个的 Lua 脚本组成的，不仅可以从磁盘上加载，也可以从 Redis、MySQL 里加载，而且编写、调试的过程非常方便快捷。


OpenResty 里还有两个不同于 Nginx 的特殊阶段：

1. 一个是“init 阶段”，它又分成“master init”和“worker init”，在 master 进程和 worker 进程启动的时候运行。
2. 另一个是“ssl 阶段”，这算得上是 OpenResty 的一大创举，可以在 TLS 握手时动态加载证书，或者发送“OCSP Stapling”。

> 参考：[OpenResty：更灵活的Web服务器](https://time.geekbang.org/column/article/118685)



## 网络应用防火墙
> 前面讲过，HTTPS 使用了 SSL/TLS 协议，加密整个通信过程，能够防止恶意窃听和窜改，保护我们的数据安全。但 HTTPS 只是网络安全中很小的一部分，仅仅保证了“通信链路安全”，让第三方无法得知传输的内容。在通信链路的两端，也就是客户端和服务器，它是无法提供保护的。


### 常见的攻击方式
> 黑客都有哪些手段来攻击 Web 服务呢？


#### CSRF
CSRF（Cross-site request forgery），**跨站请求伪造**，是指攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。

::: warning 攻击流程如下：
- 受害者登录`http://a.com` ，并保留了登录凭证（Cookie）
- 攻击者引诱受害者访问了 `http://b.com`
- `http://b.com` 发送了一个请求：`http://a.com/act=xx` 。浏览器会默认携带 `http://a.com` 的Cookie。
- `http://a.com` 接收到请求后，对请求进行验证，并确认是受害者的凭证，误以为是受害者自己发送的请求。
- `http://a.com` 以受害者的名义执行了`act=xx`。
- 攻击完成，攻击者在受害者不知情的情况下冒充受害者，让 `http://a.com` 执行了自己定义的操作。
:::


- **CSRF 常见的攻击方式**

1. 自动发起 GET 请求的 CSRF
> 如：`<img src="http://a.com/pay?amount=10000&for=hacker" > `，攻击者将支付的接口请求隐藏在 `img` 标签内，在加载这个标签时，浏览器会自动发起 `img` 的资源请求，`a.com` 就会收到包含受害者登录信息的一次跨域请求

2. 自动发起 POST 请求的 CSRF
> 这种就是表单提交，访问页面后，表单会自动提交，相当于模拟用户完成了一次 POST 操作。

3. 引诱用户点击链接的 CSRF
> 这种类型通常是在论坛中发布的图片中嵌入恶意链接，或者以广告的形式诱导用户中招，攻击者通常会以比较夸张的词语诱骗用户点击，如：
``` js
<div>
  <img width=150 src=http://images.xuejuzi.cn/1612/1_161230185104_1.jpg> </img> 
  <a href="https://a.com/pay?amount=10000&for=hacker" taget="_blank">
    点击查看更多美女
  </a>
</div>
```
> 由于之前用户登录了信任的网站A，并且保存登录状态，只要用户点击了这个超链接，则表示攻击成功。


- **防护策略**

1. 利用 Cookie 的 SameSite 属性
> 通常 CSRF 攻击都是从第三方站点发起的，冒用受害者在被攻击网站的登录凭证。

可通过设置 Cookie 中的 SameSite 属性解决：

::: tip Cookie 中的 SameSite 有以下三个值
- **Strict**：浏览器完全禁止第三方拿到 Cookie
- **Lax**：相对宽松一点，在跨站点的情况下，从第三方站点的链接打开或 Get 方式的表单提交这两种方式都会携带 Cookie；除此之外，如 Post 请求、 img、iframe 等加载的 URL，都不会携带 Cookie
- **None**：最宽松，在任何情况下都会发送 Cookie 数据
> Chrome 80.0 中将 SameSite 的默认值设为 Lax
:::
所以，我们可以将 SameSite 设置为  Strict 或 Lax 来解决 Cookie 问题。



2. 利用同源策略
> 既然CSRF大多来自第三方网站，那么我们就直接禁止外域（或者不受信任的域名）对我们发起请求。

在HTTP协议中，每一个异步请求都会携带两个Header，用于标记来源域名：
- **Referer Header**：记录该请求的来源地址（含URL路径）
- **Origin Header**：记录该请求的域名信息（不含URL路径）

服务器先判断 Origin，如果请求头中没有包含 Origin 属性，再根据实际情况判断是否使用 Referer 值，看是否是同源请求。

3. Token 认证
> 前面讲到CSRF的另一个特征是，攻击者无法直接窃取到用户的信息（Cookie，Header，网站内容等），仅仅是冒用Cookie中的信息。

所以，我们可以启用 Token 认证：
- 在用户登录时，服务器生成一个 Token 返回给用户
- 在浏览器端向服务器发起请求时，带上 Token，服务器端验证 Token


#### XSS 攻击
XSS 是**跨站脚本攻击**（Cross Site Scripting），为了与 CSS 区别开来，故简称 XSS。

XSS 攻击是指往页面恶意的注入脚代码本。当用户浏览该页时，嵌入其中的 Script 代码会被执行，从而达到恶意攻击用户的目的。
> 页面被注入了恶意 JavaScript 脚本时，浏览器是无法区分这些脚本是否是被恶意注入的还是正常的页面脚本，所以恶意注入 JavaScript 脚本也拥有所有的脚本权限。它可以拿到 Cookie 信息、监听用户行为、更改 DOM 结构、在页面内生成浮窗广告、劫持流量实现恶意跳转。

例如在网页中恶意注入以下语句，当网站被访问时就会自动跳到该链接~
``` js
<script>window.location.href="https://www.verneyzhou-code.cn/";</script>
```

- **XSS 是如何注入的**

1. 存储型 XSS 攻击

存储型 XSS 攻击是指黑客利用站点漏洞将一段恶意 JavaScript 代码提交到网站的数据库中 存储 ，当用户访问网站的时候，网站将恶意脚本同正常页面一起返回，浏览器解析执行了网站中的恶意脚本，将用户的 Cookie 信息等数据上传到恶意服务器。
> 存储型 XSS 攻击经常出现在个人信息或发表文章等地方，插入代码，如果没有过滤或过滤不严，那么这些代码将储存到服务器中，用户访问该页面的时候触发代码执行。这种 XSS 比较危险，容易造成蠕虫，盗窃 cookie 等

2. 反射型 XSS 攻击

反射型 XSS 一般是黑客通过特定的手段（例如电子邮件等），诱导用户去访问一个包含恶意脚本的 URL，当用户访问这个带有恶意脚本的 URL 时，网站又把恶意 JavaScript 脚本返回给用户执行
> 反射型 XSS 通常出现在网站的搜索栏、用户登录口等地方，常用来窃取客户端 Cookies 或进行钓鱼欺骗

3. 基于 DOM 的 XSS 攻击

基于 DOM 的 XSS 攻击是指通过恶意脚本修改页面的 DOM 结构，是纯粹发生在客户端的攻击。
> DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞。


- **如何阻止 XSS 攻击**
> 无论是上面的哪种 XSS 攻击，都是恶意的向浏览器注入脚本，然后通过恶意脚本将用户信息发送到恶意服务器上，所以我们要阻止 XSS 攻击，就要**阻止恶意脚本的注入与恶意信息的发送**。

**常见的阻止 XSS 的策略有：**

1. 过滤特殊字符，或对特定字符进行编译转码
> 例如对 `script>alert(document.cookie)</script>` 进行过滤为 ，或直接转码成 `&lt;script&gt;alert(&#39;document.cookie&#39;)&lt;/script&gt;` ，这样就不会在页面执行了

2. 对重要的 cookie 设置 httpOnly
> 通过对重要的 Cookie 设置 httpOnly ，防止客户端通过 document.cookie 读取 cookie ，也就是说，JavaScript 读取不到此条 Cookie ，也就无法提交给恶意服务器了；此 HTTP 头由服务端设置。

3. URLEncode 操作
> 将不可信的值输出 URL参数之前，进行 URLEncode操作。对于从 URL 参数中获取值一定要进行格式检测（比如你需要的时URL，就判读是否满足URL格式）

4. Web 安全头支持
> 浏览器自带的防御能力，一般是通过开启 Web 安全头生效的。具体有：CSP、X-Download-Options: noopen、X-Content-Type-Options: nosniff、X-XSS-Protection


#### SQL 注入攻击
SQL注入是一种非常常见的数据库攻击手段，也是网络世界中最普遍的漏洞之一，它其实就是黑客在表单中填写包含 SQL 关键字的数据，表单数据提交给服务器时让数据库执行恶意 SQL 的过程。
> 例如 `' OR '1'='1` ，当我们输如用户名 admin ，然后密码输如 `' OR '1'=1='1` 的时候，我们在查询用户名和密码是否正确的时候，本来要执行的是 `SELECT * FROM user WHERE username='' and password=''` ,经过参数拼接后，会执行 SQL语句  `SELECT * FROM user WHERE username='' and password='' OR '1'='1'` ，这个时候`1=1`是成立，自然就跳过验证了。

- **如何防止 SQL 注入**

主要是后端进行对 SQL 注入攻击的防护，常见的防护机制有：
1. 使用 preparestatement 预编译机制：在sql语句执行前，对其进行语法分析、编译和优化，其中参数位置使用占位符 ? 代替了。当真正运行时，传过来的参数会被看作是一个纯文本，不会重新编译，不会被当做sql指令
2. 特殊字符转义： 些特殊字符，比如：`%`作为`like`语句中的参数时，要对其进行转义处理
3. 使用代码检测工具： 使用sqlMap等代码检测工具，它能检测sql注入漏洞
4. 数据库账号增加权限控制、数据库异常监控等等



#### DDoS 攻击
DDoS：**分布式拒绝服务攻击**（Distributed Denial of Service Attack），有时候也叫“洪水攻击”。
> 黑客会控制许多“僵尸”计算机，向目标服务器发起大量无效请求。因为服务器无法区分正常用户和黑客，只能“照单全收”，这样就挤占了正常用户所应有的资源。如果黑客的攻击强度很大，就会像“洪水”一样对网站的服务能力造成冲击，耗尽带宽、CPU 和内存，导致网站完全无法提供正常服务。

> “DDoS”攻击方式比较“简单粗暴”，虽然很有效，但不涉及 HTTP 协议内部的细节，“技术含量”比较低。

为了防御 DDoS 攻击，阿里巴巴的安全团队在实战中发现，需要做的就是**检测技术**和**清洗技术**，检测技术就是检测网站是否正在遭受 DDoS 攻击，而清洗技术就是清洗掉异常流量。


#### 上传文件攻击
如果 web 网站没有对文件类型进行严格的校验，导致可执行文件被恶意上传到了服务器，恶意脚本就会执行。

::: warning 如何防止
- 文件上传后放到独立的存储上，做静态文件处理，杜绝脚本执行的可能
- 对上传文件类型进行白名单校验
- 使用随机数改写文件名和文件路径等等
:::

#### DNS 查询攻击
> 我们通过域名访问网页的时候，会首先进行域名解析：DNS 系统在计算域名的 IP 地址时，会先搜索自己的本地缓存，然后一层层的往上查询 DNS 服务器。具体可参考[这里](./intro.html#域名的解析)

DNS 查询攻击就是攻击者通过精心构造 DNS报文 ，在 DNS 查询解析某个域名时，冒充真正的权威 DNS 做出回应，使得用户访问得到一个虚假响应。一旦本地接受了这个虚假响应并写入缓存，DNS 就会被攻击，用户也不清楚自己正在访问错误的地址或数据。
> 关于防御的话，就是限制DNS解析器仅响应来自可信源的查询或者关闭DNS服务器的递归查询等。


- [参考1](https://mp.weixin.qq.com/s/NsTKrkR4hCNDJvpHBzh0Bw)、[参考2](https://mp.weixin.qq.com/s/Y7MNhOUEvLZJ7wwkEobC4g)


### 网络应用防火墙（WAF）

- 面对这么多的黑客攻击手段，我们应该怎么防御呢？

这就要用到**网络应用防火墙**（Web Application Firewall）了，简称为**WAF**。

传统“防火墙”工作在三层或者四层，隔离了外网和内网，使用预设的规则，只允许某些特定 IP 地址和端口号的数据包通过，拒绝不符合条件的数据流入或流出内网，实质上是一种**网络数据过滤设备**。

WAF 也是一种“防火墙”，但它工作在七层，看到的不仅是 IP 地址和端口号，还能看到整个 HTTP 报文，所以就能够对报文内容做更深入细致的审核，使用更复杂的条件、规则来过滤数据。WAF 就是一种**HTTP 入侵检测和防御系统**。

::: tip WAF要具备下面的一些功能：
- IP 黑名单和白名单，拒绝黑名单上地址的访问，或者只允许白名单上的用户访问；
- URI 黑名单和白名单，与 IP 黑白名单类似，允许或禁止对某些 URI 的访问；
- 防护 DDoS 攻击，对特定的 IP 地址限连限速；
- 过滤请求报文，防御“代码注入”攻击；
- 过滤响应报文，防御敏感信息外泄；
- 审计日志，记录所有检测到的入侵操作。
:::

它就像是平时编写程序时必须要做的函数入口参数检查，拿到 HTTP 请求、响应报文，用字符串处理函数看看有没有关键字、敏感词，或者用正则表达式做一下模式匹配，命中了规则就执行对应的动作，比如返回 403/404。

如果你比较熟悉 Apache、Nginx、OpenResty，可以自己改改配置文件，写点 JS 或者 Lua 代码，就能够实现基本的 WAF 功能：
``` shell
map $remote_addr $blocked {
    default       0;
    "1.2.3.4"     1;
    "5.6.7.8"     1;
}


if ($blocked) {
    return 403 "you are blocked.";  
}
```
> 比如说，在 Nginx 里实现 IP 地址黑名单，可以利用“map”指令，从变量 $remote_addr 获取 IP 地址，在黑名单上就映射为值 1，然后在“if”指令里判断

- 在网络安全领域必须时刻记得**木桶效应**（也叫“短板效应”）。网站的整体安全不在于你加固的最强的那个方向，而是在于你可能都没有意识到的“短板”。黑客往往会“避重就轻”，只要发现了网站的一个弱点，就可以“一点突破”，其他方面的安全措施也就都成了“无用功”。


### 全面的 WAF 解决方案
WAF 领域里的最顶级产品了：ModSecurity，它可以说是 WAF 界“事实上的标准”。

ModSecurity 是一个开源的、生产级的 WAF 工具包，历史很悠久，比 Nginx 还要大几岁。它开始于一个私人项目，后来被商业公司 Breach Security 收购，现在则是由 TrustWave 公司的 SpiderLabs 团队负责维护。

- ModSecurity 有两个核心组件。第一个是**规则引擎**，它实现了自定义的“SecRule”语言，有自己特定的语法。但“SecRule”主要基于正则表达式，还是不够灵活，所以后来也引入了 Lua，实现了脚本化配置。

- 只有引擎还不够，要让引擎运转起来，还需要完善的防御规则，所以 ModSecurity 的第二个核心组件就是它的**规则集**。
    - 基本的规则集之外，ModSecurity 还额外提供一个更完善的规则集，为网站提供全面可靠的保护。这个规则集的全名叫**OWASP ModSecurity 核心规则集**（Open Web Application Security Project ModSecurity Core Rule Set），因为名字太长了，所以有时候会简称为“核心规则集”或者“CRS”。


## CDN
> 到目前为止，我们先来看看到现在为止 HTTP 手头都有了哪些“武器”；协议方面，HTTPS 强化通信链路安全、HTTP/2 优化传输效率；应用方面，Nginx/OpenResty 提升网站服务能力，WAF 抵御网站入侵攻击。

在应用领域，还缺一个在外部加速 HTTP 协议的服务，这个就是 CDN（Content Delivery Network 或 Content Distribution Network），中文名叫“内容分发网络”。

CDN 就是专门为解决“长距离”上网络访问速度慢而诞生的一种网络应用服务。

CDN 有三个关键词：**“内容”“分发”和“网络”**：

- **网络**：CDN 的最核心原则是“就近访问”，如果用户能够在本地几十公里的距离之内获取到数据，那么时延就基本上变成 0 了。
    - 所以 CDN 投入了大笔资金，在全国、乃至全球的各个大枢纽城市都建立了机房，部署了大量拥有高存储高带宽的节点，构建了一个专用网络。
- **分发**：有了这个高速的专用网之后，CDN 就要**分发**”源站的“内容”了，用到的就是 HTTP 的“缓存代理”技术。
    - 用户在上网的时候就不直接访问源站，而是访问离他“最近的”一个 CDN 节点，术语叫**边缘节点**（edge node），其实就是缓存了源站内容的代理服务器，这样一来就省去了“长途跋涉”的时间成本，实现了“网络加速”。

- **内容**：在 CDN 领域里，**内容**其实就是 HTTP 协议里的“资源”，比如超文本、图片、视频、应用程序安装包等等。
    - 资源按照是否可缓存又分为“静态资源”和“动态资源”。所谓的“静态资源”是指数据内容“静态不变”，任何时候来访问都是一样的，比如图片、音频。
    - 所谓的“动态资源”是指数据内容是“动态变化”的，也就是由后台服务计算生成的，每次访问都不一样，比如商品的库存、微博的粉丝数等。
    - 如果动态资源指定了“Cache-Control”，允许缓存短暂的时间，那它在这段时间里也就变成了“静态资源”，可以被 CDN 缓存加速。


### CDN 的负载均衡

我们再来看看 CDN 是具体怎么运行的，它有两个关键组成部分：**全局负载均衡和缓存系统**。

- **全局负载均衡**
>（Global Sever Load Balance）一般简称为 **GSLB**，它是 CDN 的“大脑”，主要的职责是当用户接入网络的时候在 CDN 专网中挑选出一个“最佳”节点提供服务，解决的是用户如何找到“最近的”边缘节点，对整个 CDN 网络进行“负载均衡”。

1. GSLB 最常见的实现方式是“DNS 负载均衡”，权威 DNS 返回的不是 IP 地址，而是一个 CNAME( Canonical Name ) 别名记录，指向的就是 CDN 的 GSLB。
2. 因为没拿到 IP 地址，于是本地 DNS 就会向 GSLB 再发起请求，这样就进入了 CDN 的全局负载均衡系统，开始“智能调度”：
    - 看用户的 IP 地址，查表得知地理位置，找相对最近的边缘节点；
    - 看用户所在的运营商网络，找相同网络的边缘节点；
    - 检查边缘节点的负载情况，找负载较轻的节点；
    - 其他，比如节点的“健康状况”、服务能力、带宽、响应时间等。
3. GSLB 把这些因素综合起来，用一个复杂的算法，最后找出一台“最合适”的边缘节点，把这个节点的 IP 地址返回给用户，用户就可以“就近”访问 CDN 的缓存代理了。

- **CDN 的缓存代理**
> 缓存系统是 CDN 的另一个关键组成部分，相当于 CDN 的“心脏”。如果缓存系统的服务能力不够，不能很好地满足用户的需求，那 GSLB 调度算法再优秀也没有用。

这里就有两个 CDN 的关键概念：“命中”和“回源”：
- **命中** 就是指用户访问的资源恰好在缓存系统里，可以直接返回给用户；
- **回源** 则正相反，缓存里没有，必须用代理的方式回源站取。

就有了两个衡量 CDN 服务质量的指标：**命中率**和**回源率**：命中率就是命中次数与所有访问次数之比，回源率是回源次数与所有访问次数之比。
> 显然，好的 CDN 应该是命中率越高越好，回源率越低越好。现在的商业 CDN 命中率都在 90% 以上，相当于把源站的服务能力放大了 10 倍以上。


Q：怎么样才能尽可能地提高命中率、降低回源率呢？

1. 首先，最基本的方式就是**在存储系统上下功夫**，硬件用高速 CPU、大内存、万兆网卡，再搭配 TB 级别的硬盘和快速的 SSD。软件方面则尽可能地高效利用存储，存下更多的内容。

2. 其次，**缓存系统也可以划分出层次，分成一级缓存节点和二级缓存节点**。一级缓存配置高一些，直连源站，二级缓存配置低一些，直连用户。回源的时候二级缓存只找一级缓存，一级缓存没有才回源站，这样最终“扇入度”就缩小了，可以有效地减少真正的回源。

3. 第三个就是**使用高性能的缓存服务**；最常用的是专门的缓存代理软件 Squid、Varnish，而 Nginx 和 OpenResty 作为 Web 服务器领域的“多面手”，凭借着强大的反向代理能力和模块化、易于扩展的优点，也在 CDN 里占据了不少的份额。

> 参考：[CDN：加速我们的网络服务](https://time.geekbang.org/column/article/120664)


## WebSocket
“WebSocket”是一种基于 TCP 的轻量级网络通信协议，在地位上是与 HTTP“平级”的。

其实 WebSocket 与 HTTP/2 一样，都是为了解决 HTTP 某方面的缺陷而诞生的。HTTP/2 针对的是“队头阻塞”，而 WebSocket 针对的是“请求 - 应答”通信模式。

Q：“请求 - 应答”有什么不好的地方呢？
> “请求 - 应答”是一种**半双工**的通信模式，虽然可以双向收发数据，但同一时刻只能一个方向上有动作，传输效率低。更关键的一点，它是一种“被动”通信模式，服务器只能“被动”响应客户端的请求，无法主动向客户端发送数据。这就导致 HTTP 难以应用在动态页面、即时消息、网络游戏等要求“实时通信”的领域。

在 WebSocket 出现之前，在浏览器环境里用 JavaScript 开发实时 Web 应用很麻烦。因为浏览器是一个“受限的沙盒”，不能用 TCP，只有 HTTP 协议可用，所以就出现了很多“变通”的技术，**轮询**（polling）就是比较常用的的一种。
> 轮询就是不停地向服务器发送 HTTP 请求，问有没有数据，有数据的话服务器就用响应报文回应。如果轮询的频率比较高，那么就可以近似地实现“实时通信”的效果。但反复发送无效查询请求耗费了大量的带宽和 CPU 资源，非常不经济。

所以，为了克服 HTTP“请求 - 应答”模式的缺点，WebSocket 就“应运而生”了。它原来是 HTML5 的一部分，后来“自立门户”，形成了一个单独的标准，RFC 文档编号是 6455。

- **WebSocket 的特点**

- WebSocket 是一个真正“全双工”的通信协议，与 TCP 一样，客户端和服务器都可以随时向对方发送数据。
    - 服务器就可以变得更加“主动”了。一旦后台有新的数据，就可以立即“推送”给客户端，不需要客户端轮询，“实时通信”的效率也就提高了。

- WebSocket 采用了**二进制帧结构**，语法、语义与 HTTP 完全不兼容。
- 服务发现方面，WebSocket 没有使用 TCP 的“IP 地址 + 端口号”，而是延用了 HTTP 的 URI 格式，但开头的协议名不是“http”，引入的是两个新的名字：**ws**和**wss**，分别表示明文和加密的 WebSocket 协议。
- WebSocket 的默认端口也选择了 80 和 443。
    - 因为现在互联网上的防火墙屏蔽了绝大多数的端口，只对 HTTP 的 80、443 端口“放行”，所以 WebSocket 就可以“伪装”成 HTTP 协议，比较容易地“穿透”防火墙，与服务器建立连接。具体是怎么“伪装”的，我稍后再讲。


- **WebSocket 的帧结构**
> WebSocket 和 HTTP/2 的关注点不同，WebSocket 更侧重于“实时通信”，而 HTTP/2 更侧重于提高传输效率，所以两者的帧结构也有很大的区别。

WebSocket 虽然有“帧”，但却没有像 HTTP/2 那样定义“流”，也就不存在“多路复用”“优先级”等复杂的特性，而它自身就是“全双工”的，也就不需要“服务器推送”。

WebSocket 的帧头就四个部分：**结束标志位 + 操作码 + 帧长度 + 掩码**，只是使用了变长编码的“小花招”，不像 HTTP/2 定长报文头那么简单明了。


- **WebSocket 的握手**
> 利用了 HTTP 本身的“协议升级”特性，“伪装”成 HTTP，这样就能绕过浏览器沙盒、网络防火墙等等限制，这也是 WebSocket 与 HTTP 的另一个重要关联点。

WebSocket 的握手是一个标准的 HTTP GET 请求，但要带上两个协议升级的专用头字段：
- “Connection: Upgrade”，表示要求协议“升级”；
- “Upgrade: websocket”，表示要“升级”成 WebSocket 协议。

另外，为了防止普通的 HTTP 消息被“意外”识别成 WebSocket，握手消息还增加了两个额外的认证用头字段（所谓的“挑战”，Challenge）：
- Sec-WebSocket-Key：一个 Base64 编码的 16 字节随机数，作为简单的认证密钥；
- Sec-WebSocket-Version：协议的版本号，当前必须是 13。

服务器收到 HTTP 请求报文，看到上面的四个字段，就知道这不是一个普通的 GET 请求，而是 WebSocket 的升级请求，于是就不走普通的 HTTP 处理流程，而是构造一个特殊的“101 Switching Protocols”响应报文，通知客户端，接下来就不用 HTTP 了，全改用 WebSocket 协议通信。
> WebSocket 的握手响应报文也是有特殊格式的，要用字段“Sec-WebSocket-Accept”验证客户端请求报文，同样也是为了防止误连接。

> 参考：[WebSocket：沙盒里的TCP](https://time.geekbang.org/column/article/121092)



## HTTP性能优化
从 HTTP 最基本的“请求 - 应答”模型来着手吧。在这个模型里有两个角色：客户端和服务器，还有中间的传输链路，考查性能就可以看这三个部分。

### HTTP 服务器
> 它一般运行在 Linux 操作系统上，用 Apache、Nginx 等 Web 服务器软件对外提供服务，所以，性能的含义就是它的服务能力，也就是尽可能多、尽可能快地处理用户的请求。

衡量服务器性能的主要指标有三个：**吞吐量（requests per second）、并发数（concurrency）和响应时间（time per request）**。

- **吞吐量**就是我们常说的 RPS，每秒的请求次数，也有叫 TPS、QPS，它是服务器最基本的性能指标，RPS 越高就说明服务器的性能越好。
- **并发数**反映的是服务器的负载能力，也就是服务器能够同时支持的客户端数量，当然也是越多越好，能够服务更多的用户。
- **响应时间**反映的是服务器的处理能力，也就是快慢程度，响应时间越短，单位时间内服务器就能够给越多的用户提供服务，提高吞吐量和并发数。

除了上面的三个基本性能指标，服务器还要考虑 CPU、内存、硬盘和网卡等系统资源的占用程度，利用率过高或者过低都可能有问题。

服务器的性能优化方向：**合理利用系统资源，提高服务器的吞吐量和并发数，降低响应时间**。


### HTTP 客户端

客户端是信息的消费者，一切数据都要通过网络从服务器获取，所以它最基本的性能指标就是**延迟**（latency）。
> 所谓的“延迟”其实就是“等待”，等待数据到达客户端时所花费的时间。HTTP 的传输链路很复杂，所以延迟的原因也就多种多样：
- 第一个“不可逾越”的障碍——**光速**，因为地理距离而导致的延迟是无法克服的，访问数千公里外的网站显然会有更大的延迟。
- 第二个因素是**带宽**，它又包括接入互联网时的电缆、WiFi、4G 和运营商内部网络、运营商之间网络的各种带宽，每一处都有可能成为数据传输的瓶颈，降低传输速度，增加延迟。
- 第三个因素是 **DNS 查询**，如果域名在本地没有缓存，就必须向 DNS 系统发起查询，引发一连串的网络通信成本，而在获取 IP 地址之前客户端只能等待，无法访问网站。
- 第四个因素是 **TCP 握手**，你应该对它比较熟悉了吧，必须要经过 SYN、SYN/ACK、ACK 三个包之后才能建立连接，它带来的延迟由光速和带宽共同决定。
> 建立 TCP 连接之后，就是正常的数据收发了，后面还有解析 HTML、执行 JavaScript、排版渲染等等，这些也会耗费一些时间。不过它们已经不属于 HTTP 了，所以不在今天的讨论范围之内。



Chrome 等浏览器自带的开发者工具也可以很好地观察客户端延迟指标：
> 点击某个 URI，在 Timing 页里会显示出一个小型的“瀑布图”，是这个资源消耗时间的详细分解

<img class="zoom-custom-imgs" :src="$withBase('/images/https/pro301.png')" width="auto"/>

- 因为有“队头阻塞”，浏览器对每个域名最多开 6 个并发连接（HTTP/1.1），当页面里链接很多的时候就必须**排队等待（Queued、Queueing）**，这里它就等待了 1.62 秒，然后才被浏览器正式处理；
- 浏览器要**预先分配资源，调度连接（Stalled）**，花费了 11.56 毫秒;
- 连接前必须要**解析域名**，这里因为有本地缓存，所以只消耗了 0.41 毫秒（**DNS Lookup**）；
- **与网站服务器建立连接**的成本很高，总共花费了 270.87 毫秒，其中有 134.89 毫秒用于 TLS 握手，那么 TCP 握手的时间就是 135.98 毫秒（**Initial connection、SSL**）；
- 实际发送数据非常快，只用了 0.11 毫秒（**Request sent**）；
- 之后就是**等待服务器的响应**，专有名词叫 **TTFB（Time To First Byte）**，也就是“首字节响应时间”，里面包括了服务器的处理时间和网络传输时间，花了 124.2 毫秒；
- 接收数据也是非常快的，用了 3.58 毫秒（**Content Dowload**）。

> 从这张图你可以看到，一次 HTTP“请求 - 响应”的过程中延迟的时间是非常惊人的，总时间 415.04 毫秒里占了差不多 99%。

所以，客户端 HTTP 性能优化的关键就是：**降低延迟**。


### HTTP 传输链路

以 HTTP 基本的“请求 - 应答”模型为出发点，大致画出如下互联网示意图：

<img class="zoom-custom-imgs" :src="$withBase('/images/https/pro302.png')" width="auto"/>

- **第一公里** 是指网站的出口，也就是服务器接入互联网的传输线路，它的带宽直接决定了网站对外的服务能力，也就是吞吐量等指标。显然，优化性能应该在这“第一公里”加大投入，尽量购买大带宽，接入更多的运营商网络。
- **中间一公里** 就是由许多小网络组成的实际的互联网，其实它远不止“一公里”，而是非常非常庞大和复杂的网络，地理距离、网络互通都严重影响了传输速度。好在这里面有一个 HTTP 的“好帮手”——CDN，它可以帮助网站跨越“千山万水”，让这段距离看起来真的就好像只有“一公里”。
- **最后一公里** 是用户访问互联网的入口，对于固网用户就是光纤、网线，对于移动用户就是 WiFi、基站。以前它是客户端性能的主要瓶颈，延迟大带宽小，但随着近几年 4G 和高速宽带的普及，“最后一公里”的情况已经好了很多，不再是制约性能的主要因素了。

除了这“三公里”，还有一个**第零公里**， 就是网站内部的 Web 服务系统。它其实也是一个小型的网络（当然也可能会非常大），中间的数据处理、传输会导致延迟，增加服务器的响应时间，也是一个不可忽视的优化点。

> 在上面整个互联网传输链路中，末端的“最后一公里”我们是无法控制的，所以我们只能在“第零公里”“第一公里”和“中间一公里”这几个部分下功夫，增加带宽降低延迟，优化传输速度。


### HTTP 性能优化手段

- 投资购买现成的硬件，花钱购买外部的软件或者服务
    - 换上更强的 CPU、更快的网卡、更大的带宽、更多的服务器，效果也会“立竿见影”，直接提升网站的服务能力，也就实现了 HTTP 优化。
    - 购买CDN，CDN 专注于网络内容交付，帮助网站解决“中间一公里”的问题，还有很多其他非常专业的优化功能。

- 开源
    > 这个“开源”可不是 Open Source，而是指抓“源头”，开发网站服务器自身的潜力，在现有条件不变的情况下尽量挖掘出更多的服务能力。
    - 我们应该选用高性能的 Web 服务器，最佳选择当然就是 Nginx/OpenResty
    - 对于 HTTP 协议一定要启用长连接，可以把成本“均摊”到多次请求里，这样只有第一次请求会有延迟，之后的请求就不会有连接延迟，总体的延迟也就降低了。

- 节流
    > “节流”是指减少客户端和服务器之间收发的数据量，在有限的带宽里传输更多的内容。
    - “节流”最基本的做法就是使用 HTTP 协议内置的“数据压缩”编码，不仅可以选择标准的 gzip，还可以积极尝试新的压缩算法 br，它有更好的压缩效果。
    - HTML/CSS/JavaScript 属于纯文本，就可以采用特殊的“压缩”，去掉源码里多余的空格、换行、注释等元素。
    - 对于小文本或者小图片，还有一种叫做“资源合并”（Concatenation）的优化方式，就是把许多小资源合并成一个大资源，节省请求次数。
    - 适当“收缩”域名，限制在两三个左右，减少解析完整域名所需的时间，让客户端尽快从系统缓存里获取解析结果。
    - 除非必要，应当尽量不使用重定向，或者使用 Web 服务器的“内部重定向”。

- 缓存
    > “缓存”不仅是 HTTP，也是任何计算机系统性能优化的“法宝”，把它和上面的“开源”“节流”搭配起来应用于传输链路，就能够让 HTTP 的性能再上一个台阶。
    - 在“第零公里”，也就是网站系统内部，可以使用 Memcache、Redis、Varnish 等专门的缓存服务，把计算的中间结果和资源存储在内存或者硬盘里，Web 服务器首先检查缓存系统，如果有数据就立即返回给客户端，省去了访问后台服务的时间。
    - 在“中间一公里”，缓存更是性能优化的重要手段，CDN 的网络加速功能就是建立在缓存的基础之上的，可以这么说，如果没有缓存，那就没有 CDN。

- HTTP/2
    > 在“开源”“节流”和“缓存”这三大策略之外，HTTP 性能优化还有一个选择，那就是把协议由 HTTP/1 升级到 HTTP/2。HTTP/2 的很多优点，它消除了应用层的队头阻塞，拥有头部压缩、二进制帧、多路复用、流量控制、服务器推送等许多新特性，大幅度提升了 HTTP 的传输效率。
    
    需要注意的是：
    - 对于 HTTP/2 来说，一个域名使用一个 TCP 连接才能够获得最佳性能，如果开多个域名，就会浪费带宽和服务器资源，也会降低 HTTP/2 的效率，所以“域名收缩”在 HTTP/2 里是必须要做的。
    - “资源合并”在 HTTP/1 里减少了多次请求的成本，但在 HTTP/2 里因为有头部压缩和多路复用，传输小文件的成本很低，所以合并就失去了意义。而且“资源合并”还有一个缺点，就是降低了缓存的可用性，只要一个小文件更新，整个缓存就完全失效，必须重新下载。

    所以在现在的大带宽和 CDN 应用场景下，应当尽量少用资源合并（JavaScript、CSS 图片合并，数据内嵌），让资源的粒度尽可能地小，才能更好地发挥缓存的作用。


<fix-link label="Back" href="/tool/http/"></fix-link>

<!-- 2021-05-07 -->