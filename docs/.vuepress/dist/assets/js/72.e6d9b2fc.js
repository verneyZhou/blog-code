(window.webpackJsonp=window.webpackJsonp||[]).push([[72],{665:function(v,a,_){"use strict";_.r(a);var t=_(8),e=Object(t.a)({},(function(){var v=this,a=v.$createElement,_=v._self._c||a;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"前端工程化-webpack入门"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#前端工程化-webpack入门"}},[v._v("#")]),v._v(" 前端工程化-webpack入门")]),v._v(" "),_("h2",{attrs:{id:"前言"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#前言"}},[v._v("#")]),v._v(" 前言")]),v._v(" "),_("p",[v._v("在开始介绍webpack之前，先简单带大家回顾下前端的发展简史~")]),v._v(" "),_("h3",{attrs:{id:"前端发展简史"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#前端发展简史"}},[v._v("#")]),v._v(" 前端发展简史")]),v._v(" "),_("ol",[_("li",[v._v("原始时代")])]),v._v(" "),_("ul",[_("li",[v._v("1989 年，任职于欧洲核子研究中心的蒂姆·伯纳斯 - 李（Tim Berners-Lee）提出了在互联网上构建超链接文档系统的构想：可以把超文本系统完美地运行在互联网上，让各地的人们能够自由地共享信息。蒂姆把这个系统称为“万维网”（World Wide Web），也就是我们现在所熟知的 Web。而HTML就一直被用作万维网的信息表示语言。")]),v._v(" "),_("li",[v._v("1993年，第一款图文混排的网页浏览器Mosaic诞生；94年网景公司（Netscape）推出网景浏览器（Netscape Navigator），迅速占领市场，成为当时最流行的浏览器。它的初衷是为了方便科研人员查阅资料、文档\nindex.html页面和它的样式文件a.css，用文本编辑器写代码，无需编译，本地预览，确认OK，丢到服务器，等待用户访问。")])]),v._v(" "),_("blockquote",[_("p",[v._v("纯内容的静态展示：HTML 写写页面模板、CSS 给页面排个好看点的版式")])]),v._v(" "),_("ol",{attrs:{start:"2"}},[_("li",[v._v("1995年，JS出现，HTML 为骨架，CSS 为外貌，JavaScript 为交互。之后1998年，aJax的出现，前端从纯内容的静态展示，发展到了动态网页，富交互，前端数据处理的新时期")])]),v._v(" "),_("blockquote",[_("p",[v._v("由于动态交互、数据交互的需求增多，还衍生出了jQuery（2006） 这样优秀的跨浏览器的 js 工具库，主要用于 DOM 操作，数据交互。")])]),v._v(" "),_("ol",{attrs:{start:"3"}},[_("li",[v._v("08年之后，NodeJs、ReactJs、VueJS相继出现")])]),v._v(" "),_("ul",[_("li",[v._v("谷歌V8引擎 和 node 的出现，使前端开发人员可以用熟悉的语法糖编写后台系统，为前端提供了使用同一语言的实现全栈开发的机会")]),v._v(" "),_("li",[v._v("React、Angular、Vue 等 MVVM 前端框架的出现，使前端实现了项目真正的应用化（SPA单页面应用）；推动了前后端的彻底分离（前端项目独立部署，不再依赖类似的 template 文件目录）")])]),v._v(" "),_("ol",{attrs:{start:"4"}},[_("li",[v._v("4G 移动网络的普及，使得前端从单一的基于的 PC 浏览器 展示的 web 应用，开始向手机、平板覆盖；前端不再仅仅是 PC web 方面的开发，手机配置，与 app 进行 hybird 开发，变成了常态。")])]),v._v(" "),_("h3",{attrs:{id:"前端工程化的发展"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#前端工程化的发展"}},[v._v("#")]),v._v(" 前端工程化的发展")]),v._v(" "),_("p",[v._v("前端越来越复杂，设计的问题和环节也越来越多，不采用工程化管理，就无法很好的实现团队协同和降低复杂性：")]),v._v(" "),_("ul",[_("li",[v._v("前端范畴不断扩大")]),v._v(" "),_("li",[v._v("前后端分离")]),v._v(" "),_("li",[v._v("模块化开发的出现")]),v._v(" "),_("li",[v._v("转码器的盛行")]),v._v(" "),_("li",[v._v("开发流程和团队")])]),v._v(" "),_("h3",{attrs:{id:"前端工程化的发展-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#前端工程化的发展-2"}},[v._v("#")]),v._v(" 前端工程化的发展")]),v._v(" "),_("blockquote",[_("p",[v._v("目前来说，Web业务日益复杂化和多元化，前端开发已经由以WebPage模式为主转变为以WebApp模式为主了。现在随便找个前端项目，都已经不是过去的拼个页面+搞几个jQuery插件就能完成的了。工程复杂了就会产生许多问题，比如：如何进行高效的多人协作？如何保证项目的可维护性？如何提高项目的开发质量？...")])]),v._v(" "),_("p",[v._v("前端工程化是前端架构中重要的一环，主要就是为了解决上述大部分问题的。而前端工程本质上是软件工程的一种，因此我们应该从软件工程的角度来研究前端工程。")]),v._v(" "),_("h4",{attrs:{id:"什么是前端工程化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是前端工程化"}},[v._v("#")]),v._v(" 什么是前端工程化？")]),v._v(" "),_("blockquote",[_("p",[v._v("工程化是一种思想，而不是某种技术。其主要目的为了提高效率和降低成本，即提高开发过程中的开发效率，减少不必要的重复工作时间等")])]),v._v(" "),_("p",[v._v("一个工程的生命周期：工程立项、需求分析、产品原型、"),_("strong",[v._v("开发实施、测试部署、上线运行")])]),v._v(" "),_("p",[v._v("前端工程化就是通过各种工具和技术，提升前端开发效率的过程。")]),v._v(" "),_("ul",[_("li",[v._v("前端工程化的内容：各种工具和技术")]),v._v(" "),_("li",[v._v("作用：通过使用工具，提升开发效率")])]),v._v(" "),_("p",[v._v("学习前端工程化，就是学习使用各种工具，解决前端开发中的各种问题")]),v._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[v._v("前端工程化要解决的问题：")]),v._v(" "),_("ul",[_("li",[v._v("项目上线前，压缩代码：减少代码体积，节省带宽或空间\n"),_("blockquote",[_("p",[v._v("原理：把代码中多余的空格，注释，不需要的内容全部去掉")])])]),v._v(" "),_("li",[v._v("对es6+或css3新特性进行转换：解决浏览器兼容性问题（caniuse）")]),v._v(" "),_("li",[v._v("对Less等css预编译语言进行编译处理：想使用Less增强css的编程性，但浏览器不能直接支持Less：支持使用变量")]),v._v(" "),_("li",[v._v("格式化代码：多人协作时，代码风格无法统一")]),v._v(" "),_("li",[v._v("...")])])]),v._v(" "),_("p",[v._v("相对应就出现解决这些问题的工具：压缩工具、转换工具、格式化工具、自动化工具、...")]),v._v(" "),_("p",[v._v("前端工程化包含的内容：")]),v._v(" "),_("ul",[_("li",[v._v("脚手架工具：创建项目基础结构、提供项目规范和约定\n"),_("ul",[_("li",[v._v("专用脚手架：vue-cli（只能创建vue项目）、create-react-app、angular-cli、")]),v._v(" "),_("li",[v._v("通用脚手架：Yeoman（可创建vue和react项目）、Plop")])])]),v._v(" "),_("li",[v._v("自动化构建：\n"),_("ul",[_("li",[v._v("简单的：npm scripts && script hooks")]),v._v(" "),_("li",[v._v("专业的：Grunt、Gulp、FIS、vite")])])]),v._v(" "),_("li",[v._v("模块化打包："),_("strong",[v._v("Webpack")]),v._v("、Rollup、Parcel")]),v._v(" "),_("li",[v._v("标准化规范：ESLint、StyleLint、Prettier")]),v._v(" "),_("li",[v._v("自动化测试：Mocha、Jest")]),v._v(" "),_("li",[v._v("自动化部署：Git Hook、Lint-staged、CI / CD")])]),v._v(" "),_("p",[_("strong",[v._v("工程化 "),_("code",[v._v("不是")]),v._v(" 某个工具！！！")])]),v._v(" "),_("p",[v._v("前端工程化的基础是node.js，现在大部分前端工程化使用的工具都是使用node.js做开发的。")]),v._v(" "),_("p",[v._v("前端工程化需要考虑哪些因素呢？应该从模块化、组件化、规范化、自动化4个方面去思考：")]),v._v(" "),_("ol",[_("li",[v._v("模块化：模块化就是把一个大的文件，拆分成多个相互依赖的小文件，按一个个模块来划分；模块化只是在文件层面上，对代码和资源的拆分")]),v._v(" "),_("li",[v._v("组件化：页面上所有的东西都可以看成组件，页面是个大型组件，可以拆成若干个中型组件，然后中型组件还可以再拆，拆成若干个小型组件；组件化是在设计层面上，对于UI的拆分")]),v._v(" "),_("li",[v._v("规范化：在项目规划初期制定的好坏对于后期的开发有一定影响。\n目录结构的制定\n编码规范：html规范、CSS规范、JS规范、图片规范、命名规范\n前后端接口规范\n文档规范\n组件管理\nGit分支管理\nCommit描述规范\n定期codeReview\n视觉图标规范")]),v._v(" "),_("li",[v._v("自动化：也就是简单重复的工作交给机器来做，自动化也就是有很多自动化工具代替我们来完成，例如持续集成、自动化构建、自动化部署、自动化测试等等")])]),v._v(" "),_("h4",{attrs:{id:"模块化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#模块化"}},[v._v("#")]),v._v(" 模块化")]),v._v(" "),_("ul",[_("li",[v._v("JS的模块化")])]),v._v(" "),_("blockquote",[_("p",[v._v("在ES6之前，JavaScript一直没有模块系统，这对开发大型复杂的前端工程造成了巨大的障碍。对此社区制定了一些模块加载方案，如CommonJS、AMD和CMD、ES6，某些框架也会有自己模块系统，比如Angular1.x。")])]),v._v(" "),_("p",[v._v("规范确定了，然后就是模块的打包和加载问题：")]),v._v(" "),_("ol",[_("li",[v._v("用Webpack+Babel将所有模块打包成一个文件同步加载，也可以打成多个chunk异步加载；")]),v._v(" "),_("li",[v._v("用SystemJS+Babel主要是分模块异步加载；")]),v._v(" "),_("li",[v._v("用浏览器的"),_("code",[v._v('<script type="module">')]),v._v("加载目前Webpack远比SystemJS流行。Safari已经支持用"),_("code",[v._v('type="module"')]),v._v("加载了。")])]),v._v(" "),_("ul",[_("li",[v._v("CSS的模块化")])]),v._v(" "),_("blockquote",[_("p",[v._v("虽然SASS、LESS、Stylus等预处理器实现了CSS的文件拆分，但没有解决CSS模块化的一个重要问题：选择器的全局污染问题。")])]),v._v(" "),_("p",[v._v("按道理，一个模块化的文件应该要隐藏内部作用域，只暴露少量接口给使用者。而按照目前预处理器的方式，导入一个CSS模块后，已存在的样式有被覆盖的风险。")]),v._v(" "),_("p",[v._v("CSS Modules仍然使用CSS，只是让JS来管理依赖。它能够最大化地结合CSS生态和JS模块化能力，目前来看是最好的解决方案。Vue的scoped style也算是一种。")]),v._v(" "),_("ul",[_("li",[v._v("资源的模块化")])]),v._v(" "),_("blockquote",[_("p",[v._v("Webpack的强大之处不仅仅在于它统一了JS的各种模块系统，取代了Browserify、RequireJS、SeaJS的工作。更重要的是它的万能模块加载理念，即所有的资源都可以且也应该模块化。")])]),v._v(" "),_("p",[v._v("资源模块化后，有三个好处：")]),v._v(" "),_("ul",[_("li",[v._v("依赖关系单一化。所有CSS和图片等资源的依赖关系统一走JS路线，无需额外处理CSS预处理器的依赖关系，也不需处理代码迁移时的图片合并、字体图片等路径问题；")]),v._v(" "),_("li",[v._v("资源处理集成化。现在可以用loader对各种资源做各种事情，比如复杂的vue-loader等等。")]),v._v(" "),_("li",[v._v("项目结构清晰化。使用Webpack后，你的项目结构总可以表示成这样的函数：dest = webpack(src, config)")])]),v._v(" "),_("h4",{attrs:{id:"组件化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#组件化"}},[v._v("#")]),v._v(" 组件化")]),v._v(" "),_("p",[v._v("页面上所有的东西都是组件。页面是个大型组件，可以拆成若干个中型组件，然后中型组件还可以再拆，拆成若干个小型组件，小型组件也可以再拆，直到拆成DOM元素为止。DOM元素可以看成是浏览器自身的组件，作为组件的基本单元。")]),v._v(" "),_("h4",{attrs:{id:"规范化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#规范化"}},[v._v("#")]),v._v(" 规范化")]),v._v(" "),_("p",[v._v("模块化和组件化确定了开发模型，而这些东西的实现就需要规范去落实。")]),v._v(" "),_("blockquote",[_("p",[v._v("其中编码规范最好采取ESLint和StyleLint等强制措施，配置git hooks可以实现Lint不过不能提交代码等机制")])]),v._v(" "),_("h4",{attrs:{id:"自动化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#自动化"}},[v._v("#")]),v._v(" 自动化")]),v._v(" "),_("p",[v._v("图标合并、持续集成、"),_("strong",[v._v("自动化构建")]),v._v("、自动化部署、自动化测试")]),v._v(" "),_("h3",{attrs:{id:"构建工具"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#构建工具"}},[v._v("#")]),v._v(" 构建工具")]),v._v(" "),_("ul",[_("li",[v._v("自动化构建是指将手动构建任务，通过命名自动执行的过程")])]),v._v(" "),_("blockquote",[_("p",[v._v("构建过程：源代码自动转换生产代码")])]),v._v(" "),_("ul",[_("li",[v._v("实现自动化构建的最简方式："),_("code",[v._v("npm scripts")])])]),v._v(" "),_("blockquote",[_("p",[v._v("npm 允许在 package.json文件中，使用scripts字段定义脚本命令："),_("code",[v._v("npm run dev")]),v._v("、并行"),_("code",[v._v("&")]),v._v("、串行"),_("code",[v._v("&&")])])]),v._v(" "),_("ul",[_("li",[v._v("Grunt：基于文件读写的方式进行自动化构建")]),v._v(" "),_("li",[v._v("Gulp：使用内存的方式进行构建")]),v._v(" "),_("li",[v._v("FIS：百度出的，集成了很多工具，全家桶")]),v._v(" "),_("li",[v._v("vite2.0")])]),v._v(" "),_("h3",{attrs:{id:"打包工具"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#打包工具"}},[v._v("#")]),v._v(" 打包工具")]),v._v(" "),_("ul",[_("li",[v._v("前端为什么需要打包工具？")])]),v._v(" "),_("blockquote",[_("p",[v._v("互联网的发现，前端越来越复杂，随着项目的负责度升级，代码规范和管理必须同步升级，于是出现了模块化规范；服务端出现commonJs，客户端AMD规范；之后出现ES modules规范；模块化很好得解决了复杂应用开发中的代码组织问题，但又产生新的问题：")])]),v._v(" "),_("ol",[_("li",[v._v("ES modules的浏览器兼容性问题")]),v._v(" "),_("li",[v._v("模块文件过多导致频繁发送网络请求问题")]),v._v(" "),_("li",[v._v("资源文件模块化的问题")])]),v._v(" "),_("blockquote",[_("p",[v._v("转换ES6语法、转换JSX、CSS前缀补全/预处理器、压缩混淆、图片压缩")])]),v._v(" "),_("ul",[_("li",[v._v("rollup、webpack、parcel、vite")])]),v._v(" "),_("ol",[_("li",[v._v("Webpack 的构建主要依赖了插件和 loader，能力比较强大")])]),v._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[v._v("评价工程化的六个维度")]),v._v(" "),_("ul",[_("li",[v._v("Code Splitting，即代码分割。这意味着在构建打包时，能够将静态资源拆分，因此在页面加载时，实现最合理的按需加载策略。")]),v._v(" "),_("li",[v._v("Hashing，即对打包资源进行版本信息映射。这个话题背后的重要技术点是最合理地利用缓存机制。\n"),_("blockquote",[_("p",[v._v("工程工具进行打包的前提就是对各个模块依赖关系进行分析，并根据依赖关系，支持开发者自行定义哈希策略。比如webpack的：hash/chunkhash/contenthash")])])]),v._v(" "),_("li",[v._v("Output Module Formats，工程输出的模块化方式也需要更加灵活，比如开发者可配置 ESM、CommonJS 等规范的构建内容导出。")]),v._v(" "),_("li",[v._v("Transformations，前端工程化离不开编译/转义过程。比如对 JavaScript 代码的压缩、对无用代码的删除（DCE）等。")]),v._v(" "),_("li",[v._v("Importing Modules")]),v._v(" "),_("li",[v._v("Non-JavaScript Resources")])])]),v._v(" "),_("h2",{attrs:{id:"webpack"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#webpack"}},[v._v("#")]),v._v(" webpack")]),v._v(" "),_("ul",[_("li",[v._v("为什么选择webpack？")])]),v._v(" "),_("blockquote",[_("p",[v._v("社区生态丰富、配置灵活和插件扩展、官方更新迭代速度快")])]),v._v(" "),_("ol",[_("li",[v._v("核心部分：通过loader处理特殊资源（图片、文字等）的加载")]),v._v(" "),_("li",[v._v("拓展：通过plugins实现各种自动化的构建任务：自动压缩")])]),v._v(" "),_("p",[v._v("核心工作流程：")]),v._v(" "),_("ul",[_("li",[v._v("找到打包入口，通过入口的import或require语句解析推断出入口需要依赖的资源模块，然后再分别解析这些资源模块中的依赖，最终得到项目中的依赖关系树；")]),v._v(" "),_("li",[v._v("然后webpack就会遍历递归这个依赖树，找到每个节点资源文件，然后交给loader配置里面的对应loader去加载对应模块；")]),v._v(" "),_("li",[v._v("最后将加载的结果放在bundle.js中，从而实现整个项目的打包。")])]),v._v(" "),_("h3",{attrs:{id:"从0到1搭建一个项目"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#从0到1搭建一个项目"}},[v._v("#")]),v._v(" 从0到1搭建一个项目")]),v._v(" "),_("h3",{attrs:{id:"打包流程分析"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#打包流程分析"}},[v._v("#")]),v._v(" 打包流程分析")]),v._v(" "),_("h3",{attrs:{id:"webpack编译原理"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#webpack编译原理"}},[v._v("#")]),v._v(" webpack编译原理")]),v._v(" "),_("h3",{attrs:{id:"手写loader"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#手写loader"}},[v._v("#")]),v._v(" 手写loader")]),v._v(" "),_("h4",{attrs:{id:"_1-sprite-loader-自动合成雪碧图的loader"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-sprite-loader-自动合成雪碧图的loader"}},[v._v("#")]),v._v(" 1.sprite-loader（自动合成雪碧图的loader）")]),v._v(" "),_("h4",{attrs:{id:"_2-markdown-loader"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-markdown-loader"}},[v._v("#")]),v._v(" 2.markdown-loader")]),v._v(" "),_("blockquote",[_("p",[v._v("将markdown文件转换为html字符串")])]),v._v(" "),_("div",{staticClass:"language-shell extra-class"},[_("pre",{pre:!0,attrs:{class:"language-shell"}},[_("code",[_("span",{pre:!0,attrs:{class:"token function"}},[v._v("npm")]),v._v(" init\n"),_("span",{pre:!0,attrs:{class:"token function"}},[v._v("npm")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token function"}},[v._v("install")]),v._v(" webpack webpack-cli\n添加命令：npm run build\n打包初试：node ./dist/bundle.js\n\n"),_("span",{pre:!0,attrs:{class:"token function"}},[v._v("npm")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token function"}},[v._v("install")]),v._v(" marked\n\n")])])]),_("h3",{attrs:{id:"手写plugins-zip-plugins-压缩构建资源为zip"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#手写plugins-zip-plugins-压缩构建资源为zip"}},[v._v("#")]),v._v(" 手写plugins：zip-plugins（压缩构建资源为zip）")]),v._v(" "),_("h3",{attrs:{id:"手写一个简单的webpack"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#手写一个简单的webpack"}},[v._v("#")]),v._v(" 手写一个简单的webpack")]),v._v(" "),_("h2",{attrs:{id:"备注"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#备注"}},[v._v("#")]),v._v(" 备注")]),v._v(" "),_("h2",{attrs:{id:"参考"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[v._v("#")]),v._v(" 参考")])])}),[],!1,null,null,null);a.default=e.exports}}]);