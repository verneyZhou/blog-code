<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Docker入门学习笔记 | 一苇</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/blog/icons/favicon.ico">
    <link rel="manifest" href="/blog/js/mainfest.json">
    <link rel="stylesheet" href="/blog/styles/css/style.css">
    <script type="utf-8" src="/blog/js/disable-user-zoom.js"></script>
    <meta name="description" content="这是阿沐的博客哦~">
    <meta name="Author" content="一苇">
    <meta rel="keywords" content="verneyzhou,阿沐,一苇,前端,docs.verneyzhou-code.cn,博客,fe,IT,技术">
    <meta http-equiv="Content-Type" content="text/html" charset="UTF-8">
    <meta name="viewport" content="width=device-width,width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    
    <link rel="preload" href="/blog/assets/css/0.styles.61668f40.css" as="style"><link rel="preload" href="/blog/assets/js/app.07c9fec8.js" as="script"><link rel="preload" href="/blog/assets/js/3.a2a245ac.js" as="script"><link rel="preload" href="/blog/assets/js/71.de1aa836.js" as="script"><link rel="preload" href="/blog/assets/js/4.245b4373.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.a9e52aed.js"><link rel="prefetch" href="/blog/assets/js/100.ad35b061.js"><link rel="prefetch" href="/blog/assets/js/101.ac9e5029.js"><link rel="prefetch" href="/blog/assets/js/102.16a9a8e0.js"><link rel="prefetch" href="/blog/assets/js/103.caa157f6.js"><link rel="prefetch" href="/blog/assets/js/104.3e18ca8e.js"><link rel="prefetch" href="/blog/assets/js/105.a5dd02c7.js"><link rel="prefetch" href="/blog/assets/js/106.4b828c0e.js"><link rel="prefetch" href="/blog/assets/js/107.b336030e.js"><link rel="prefetch" href="/blog/assets/js/108.be061940.js"><link rel="prefetch" href="/blog/assets/js/109.aee5ed5f.js"><link rel="prefetch" href="/blog/assets/js/11.c503bf7b.js"><link rel="prefetch" href="/blog/assets/js/110.0ec777cb.js"><link rel="prefetch" href="/blog/assets/js/111.deced91b.js"><link rel="prefetch" href="/blog/assets/js/112.fdabdec2.js"><link rel="prefetch" href="/blog/assets/js/113.cdfd38f4.js"><link rel="prefetch" href="/blog/assets/js/114.6ec0e736.js"><link rel="prefetch" href="/blog/assets/js/115.0893ab84.js"><link rel="prefetch" href="/blog/assets/js/116.404ee8fe.js"><link rel="prefetch" href="/blog/assets/js/117.5de970f4.js"><link rel="prefetch" href="/blog/assets/js/118.328e12ba.js"><link rel="prefetch" href="/blog/assets/js/119.6b414771.js"><link rel="prefetch" href="/blog/assets/js/12.06f5d794.js"><link rel="prefetch" href="/blog/assets/js/120.db669f9a.js"><link rel="prefetch" href="/blog/assets/js/121.e2682bfc.js"><link rel="prefetch" href="/blog/assets/js/122.65d64dbd.js"><link rel="prefetch" href="/blog/assets/js/123.c207d603.js"><link rel="prefetch" href="/blog/assets/js/124.d15fa68e.js"><link rel="prefetch" href="/blog/assets/js/125.4dec074a.js"><link rel="prefetch" href="/blog/assets/js/126.690a3d94.js"><link rel="prefetch" href="/blog/assets/js/127.1566956e.js"><link rel="prefetch" href="/blog/assets/js/128.9085def5.js"><link rel="prefetch" href="/blog/assets/js/129.1467f48a.js"><link rel="prefetch" href="/blog/assets/js/13.b8ba6830.js"><link rel="prefetch" href="/blog/assets/js/130.9a8b6b82.js"><link rel="prefetch" href="/blog/assets/js/131.c78c2c45.js"><link rel="prefetch" href="/blog/assets/js/132.0dd6e0ce.js"><link rel="prefetch" href="/blog/assets/js/133.763cb3cd.js"><link rel="prefetch" href="/blog/assets/js/134.c01f5483.js"><link rel="prefetch" href="/blog/assets/js/135.1a2f1d85.js"><link rel="prefetch" href="/blog/assets/js/136.2a5f1b57.js"><link rel="prefetch" href="/blog/assets/js/137.d6055675.js"><link rel="prefetch" href="/blog/assets/js/138.7e622d6d.js"><link rel="prefetch" href="/blog/assets/js/139.1f935558.js"><link rel="prefetch" href="/blog/assets/js/14.af682e8e.js"><link rel="prefetch" href="/blog/assets/js/140.051a5152.js"><link rel="prefetch" href="/blog/assets/js/141.e3329fdf.js"><link rel="prefetch" href="/blog/assets/js/142.5512076f.js"><link rel="prefetch" href="/blog/assets/js/143.1ec337c6.js"><link rel="prefetch" href="/blog/assets/js/144.f2251ef4.js"><link rel="prefetch" href="/blog/assets/js/145.3437fb76.js"><link rel="prefetch" href="/blog/assets/js/146.a7b31c4e.js"><link rel="prefetch" href="/blog/assets/js/147.3cc8e885.js"><link rel="prefetch" href="/blog/assets/js/148.b1507e1c.js"><link rel="prefetch" href="/blog/assets/js/149.e35da13a.js"><link rel="prefetch" href="/blog/assets/js/15.e0f3979f.js"><link rel="prefetch" href="/blog/assets/js/150.dfc8c76e.js"><link rel="prefetch" href="/blog/assets/js/151.ae2fd7df.js"><link rel="prefetch" href="/blog/assets/js/152.a7376201.js"><link rel="prefetch" href="/blog/assets/js/153.93a9317a.js"><link rel="prefetch" href="/blog/assets/js/154.175cf9a5.js"><link rel="prefetch" href="/blog/assets/js/155.7c9785ed.js"><link rel="prefetch" href="/blog/assets/js/156.0282bdc8.js"><link rel="prefetch" href="/blog/assets/js/157.25f81c7a.js"><link rel="prefetch" href="/blog/assets/js/158.eccb37d9.js"><link rel="prefetch" href="/blog/assets/js/159.4c355ed2.js"><link rel="prefetch" href="/blog/assets/js/16.3ee40a8a.js"><link rel="prefetch" href="/blog/assets/js/160.94e077fb.js"><link rel="prefetch" href="/blog/assets/js/161.eb5ffc76.js"><link rel="prefetch" href="/blog/assets/js/162.23d751c6.js"><link rel="prefetch" href="/blog/assets/js/163.c80f21ab.js"><link rel="prefetch" href="/blog/assets/js/164.b16f2865.js"><link rel="prefetch" href="/blog/assets/js/165.f53b159e.js"><link rel="prefetch" href="/blog/assets/js/166.10750116.js"><link rel="prefetch" href="/blog/assets/js/167.90a6c559.js"><link rel="prefetch" href="/blog/assets/js/168.322e1048.js"><link rel="prefetch" href="/blog/assets/js/169.b1e52fae.js"><link rel="prefetch" href="/blog/assets/js/17.81f8937d.js"><link rel="prefetch" href="/blog/assets/js/170.da92790a.js"><link rel="prefetch" href="/blog/assets/js/171.220b5b50.js"><link rel="prefetch" href="/blog/assets/js/172.1493cc65.js"><link rel="prefetch" href="/blog/assets/js/173.bc9bf937.js"><link rel="prefetch" href="/blog/assets/js/174.1ad2d9fd.js"><link rel="prefetch" href="/blog/assets/js/175.07328d2d.js"><link rel="prefetch" href="/blog/assets/js/176.539278f3.js"><link rel="prefetch" href="/blog/assets/js/177.bdaef503.js"><link rel="prefetch" href="/blog/assets/js/178.06d40ce5.js"><link rel="prefetch" href="/blog/assets/js/179.a8d2460d.js"><link rel="prefetch" href="/blog/assets/js/18.58a7b3ca.js"><link rel="prefetch" href="/blog/assets/js/180.acb7e178.js"><link rel="prefetch" href="/blog/assets/js/181.04230a04.js"><link rel="prefetch" href="/blog/assets/js/182.2bae84da.js"><link rel="prefetch" href="/blog/assets/js/183.1aefb498.js"><link rel="prefetch" href="/blog/assets/js/184.aae32a59.js"><link rel="prefetch" href="/blog/assets/js/185.5194e169.js"><link rel="prefetch" href="/blog/assets/js/186.3f8a60e6.js"><link rel="prefetch" href="/blog/assets/js/187.19f86e8d.js"><link rel="prefetch" href="/blog/assets/js/188.75afe9d8.js"><link rel="prefetch" href="/blog/assets/js/189.bbf10e7f.js"><link rel="prefetch" href="/blog/assets/js/19.4facbfcd.js"><link rel="prefetch" href="/blog/assets/js/190.f0753b6c.js"><link rel="prefetch" href="/blog/assets/js/191.4fe8aa98.js"><link rel="prefetch" href="/blog/assets/js/192.8d7ef6bf.js"><link rel="prefetch" href="/blog/assets/js/193.465cd98e.js"><link rel="prefetch" href="/blog/assets/js/194.11092fca.js"><link rel="prefetch" href="/blog/assets/js/195.a4f0d47c.js"><link rel="prefetch" href="/blog/assets/js/196.dabf1015.js"><link rel="prefetch" href="/blog/assets/js/197.e9ad0ceb.js"><link rel="prefetch" href="/blog/assets/js/198.f1abb7d4.js"><link rel="prefetch" href="/blog/assets/js/199.6561e896.js"><link rel="prefetch" href="/blog/assets/js/20.c69c50ee.js"><link rel="prefetch" href="/blog/assets/js/200.02925058.js"><link rel="prefetch" href="/blog/assets/js/21.d36db816.js"><link rel="prefetch" href="/blog/assets/js/22.aa826409.js"><link rel="prefetch" href="/blog/assets/js/23.fdb82899.js"><link rel="prefetch" href="/blog/assets/js/24.9c7a84ee.js"><link rel="prefetch" href="/blog/assets/js/25.aef2c75d.js"><link rel="prefetch" href="/blog/assets/js/26.3e3cbaca.js"><link rel="prefetch" href="/blog/assets/js/27.09b82b4f.js"><link rel="prefetch" href="/blog/assets/js/28.47f73845.js"><link rel="prefetch" href="/blog/assets/js/29.7eda190b.js"><link rel="prefetch" href="/blog/assets/js/30.136a4618.js"><link rel="prefetch" href="/blog/assets/js/31.c1600861.js"><link rel="prefetch" href="/blog/assets/js/32.964dbed2.js"><link rel="prefetch" href="/blog/assets/js/33.54b1d113.js"><link rel="prefetch" href="/blog/assets/js/34.4db629ab.js"><link rel="prefetch" href="/blog/assets/js/35.fccd851c.js"><link rel="prefetch" href="/blog/assets/js/36.4b61e107.js"><link rel="prefetch" href="/blog/assets/js/37.57ec2f3b.js"><link rel="prefetch" href="/blog/assets/js/38.29752a9f.js"><link rel="prefetch" href="/blog/assets/js/39.75cc18af.js"><link rel="prefetch" href="/blog/assets/js/40.28c2824c.js"><link rel="prefetch" href="/blog/assets/js/41.9564a4e6.js"><link rel="prefetch" href="/blog/assets/js/42.91f6d891.js"><link rel="prefetch" href="/blog/assets/js/43.b716e9bd.js"><link rel="prefetch" href="/blog/assets/js/44.a3c65dbb.js"><link rel="prefetch" href="/blog/assets/js/45.62602816.js"><link rel="prefetch" href="/blog/assets/js/46.db7ce530.js"><link rel="prefetch" href="/blog/assets/js/47.39b634bf.js"><link rel="prefetch" href="/blog/assets/js/48.3e02495b.js"><link rel="prefetch" href="/blog/assets/js/49.b343e1d0.js"><link rel="prefetch" href="/blog/assets/js/5.f9c6355e.js"><link rel="prefetch" href="/blog/assets/js/50.02654870.js"><link rel="prefetch" href="/blog/assets/js/51.508610ea.js"><link rel="prefetch" href="/blog/assets/js/52.8587e4b0.js"><link rel="prefetch" href="/blog/assets/js/53.772c2349.js"><link rel="prefetch" href="/blog/assets/js/54.dceb3c84.js"><link rel="prefetch" href="/blog/assets/js/55.b6c5e568.js"><link rel="prefetch" href="/blog/assets/js/56.f3649d8f.js"><link rel="prefetch" href="/blog/assets/js/57.db204c08.js"><link rel="prefetch" href="/blog/assets/js/58.05567cee.js"><link rel="prefetch" href="/blog/assets/js/59.208c9eb8.js"><link rel="prefetch" href="/blog/assets/js/6.9db196de.js"><link rel="prefetch" href="/blog/assets/js/60.31a8d24d.js"><link rel="prefetch" href="/blog/assets/js/61.86d9151c.js"><link rel="prefetch" href="/blog/assets/js/62.22c9a5bf.js"><link rel="prefetch" href="/blog/assets/js/63.56d96fe2.js"><link rel="prefetch" href="/blog/assets/js/64.24cc5ce1.js"><link rel="prefetch" href="/blog/assets/js/65.78f53722.js"><link rel="prefetch" href="/blog/assets/js/66.fd0ee3c5.js"><link rel="prefetch" href="/blog/assets/js/67.b962d643.js"><link rel="prefetch" href="/blog/assets/js/68.5faa2f5c.js"><link rel="prefetch" href="/blog/assets/js/69.91e84aee.js"><link rel="prefetch" href="/blog/assets/js/7.bbc1a47a.js"><link rel="prefetch" href="/blog/assets/js/70.594379e0.js"><link rel="prefetch" href="/blog/assets/js/72.2aa72a71.js"><link rel="prefetch" href="/blog/assets/js/73.6ebb152b.js"><link rel="prefetch" href="/blog/assets/js/74.1e5ced20.js"><link rel="prefetch" href="/blog/assets/js/75.42650e07.js"><link rel="prefetch" href="/blog/assets/js/76.3b79fc70.js"><link rel="prefetch" href="/blog/assets/js/77.c30ea800.js"><link rel="prefetch" href="/blog/assets/js/78.c1ff86f4.js"><link rel="prefetch" href="/blog/assets/js/79.21e4acaa.js"><link rel="prefetch" href="/blog/assets/js/8.7ca5bcb9.js"><link rel="prefetch" href="/blog/assets/js/80.5bee662d.js"><link rel="prefetch" href="/blog/assets/js/81.cdd99cd8.js"><link rel="prefetch" href="/blog/assets/js/82.94998af0.js"><link rel="prefetch" href="/blog/assets/js/83.f855f660.js"><link rel="prefetch" href="/blog/assets/js/84.31640995.js"><link rel="prefetch" href="/blog/assets/js/85.ca4960fe.js"><link rel="prefetch" href="/blog/assets/js/86.d630b6a3.js"><link rel="prefetch" href="/blog/assets/js/87.838e1edc.js"><link rel="prefetch" href="/blog/assets/js/88.7071fdf7.js"><link rel="prefetch" href="/blog/assets/js/89.2627c1c2.js"><link rel="prefetch" href="/blog/assets/js/9.ec25f2ab.js"><link rel="prefetch" href="/blog/assets/js/90.ad5271ed.js"><link rel="prefetch" href="/blog/assets/js/91.48371907.js"><link rel="prefetch" href="/blog/assets/js/92.151045b8.js"><link rel="prefetch" href="/blog/assets/js/93.6fbcc77a.js"><link rel="prefetch" href="/blog/assets/js/94.fec3895c.js"><link rel="prefetch" href="/blog/assets/js/95.729004de.js"><link rel="prefetch" href="/blog/assets/js/96.20d668b4.js"><link rel="prefetch" href="/blog/assets/js/97.017f8b9c.js"><link rel="prefetch" href="/blog/assets/js/98.5a463e71.js"><link rel="prefetch" href="/blog/assets/js/99.1c2ec226.js"><link rel="prefetch" href="/blog/assets/js/vendors~flowchart.381052ad.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.61668f40.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><img src="/blog/icons/apple-touch-icon.png" alt="一苇" class="logo"> <span class="site-name can-hide">一苇</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/archives/" class="nav-link">时间轴</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="基础" class="dropdown-title"><!----> <span class="title" style="display:;">基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/frontend/js/" class="nav-link">JS</a></li><li class="dropdown-item"><!----> <a href="/blog/frontend/html/" class="nav-link">HTML</a></li><li class="dropdown-item"><!----> <a href="/blog/frontend/css/" class="nav-link">CSS</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="进阶" class="dropdown-title"><!----> <span class="title" style="display:;">进阶</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/skills/vue/" class="nav-link">Vue</a></li><li class="dropdown-item"><!----> <a href="/blog/skills/webpack/" class="nav-link">Webpack</a></li><li class="dropdown-item"><!----> <a href="/blog/code/" class="nav-link">源码</a></li><li class="dropdown-item"><!----> <a href="/blog/more/web3/" class="nav-link">Web3</a></li><li class="dropdown-item"><!----> <a href="/blog/more/" class="nav-link router-link-active">更多</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="项目" class="dropdown-title"><!----> <span class="title" style="display:;">项目</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>PC端</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/project/vue-node-admin/" class="nav-link">vue-node-admin</a></li><li class="dropdown-subitem"><a href="/blog/skills/vue/vue3-vite-admin.html" class="nav-link">vue3-vite-admin</a></li><li class="dropdown-subitem"><a href="/blog/skills/vue/vue3-cli-admin.html" class="nav-link">vue3-cli-admin</a></li><li class="dropdown-subitem"><a href="/blog/skills/vue/vue3-webpack5-admin.html" class="nav-link">vue3-webpack5-admin</a></li><li class="dropdown-subitem"><a href="/blog/project/mono-react-project.html" class="nav-link">teach-react-mono</a></li></ul></li><li class="dropdown-item"><h4>移动端</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/project/mobile-h5/" class="nav-link">微信h5</a></li><li class="dropdown-subitem"><a href="/blog/project/mini-program/" class="nav-link">微信小程序</a></li><li class="dropdown-subitem"><a href="/blog/project/mobile/" class="nav-link">移动端开发笔记</a></li></ul></li></ul></div></div><div class="nav-item"><a href="/blog/tool/" class="nav-link">其他</a></div><div class="nav-item"><a href="https://github.com/verneyZhou" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="关于" class="dropdown-title"><!----> <span class="title" style="display:;">关于</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/about/" class="nav-link">ME</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="images/poster03.jpeg"> <div class="blogger-info"><h3></h3> <span>光阴缝隙，时间盛典。</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/blog/archives/" class="nav-link">时间轴</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="基础" class="dropdown-title"><!----> <span class="title" style="display:;">基础</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/frontend/js/" class="nav-link">JS</a></li><li class="dropdown-item"><!----> <a href="/blog/frontend/html/" class="nav-link">HTML</a></li><li class="dropdown-item"><!----> <a href="/blog/frontend/css/" class="nav-link">CSS</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="进阶" class="dropdown-title"><!----> <span class="title" style="display:;">进阶</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/skills/vue/" class="nav-link">Vue</a></li><li class="dropdown-item"><!----> <a href="/blog/skills/webpack/" class="nav-link">Webpack</a></li><li class="dropdown-item"><!----> <a href="/blog/code/" class="nav-link">源码</a></li><li class="dropdown-item"><!----> <a href="/blog/more/web3/" class="nav-link">Web3</a></li><li class="dropdown-item"><!----> <a href="/blog/more/" class="nav-link router-link-active">更多</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="项目" class="dropdown-title"><!----> <span class="title" style="display:;">项目</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>PC端</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/project/vue-node-admin/" class="nav-link">vue-node-admin</a></li><li class="dropdown-subitem"><a href="/blog/skills/vue/vue3-vite-admin.html" class="nav-link">vue3-vite-admin</a></li><li class="dropdown-subitem"><a href="/blog/skills/vue/vue3-cli-admin.html" class="nav-link">vue3-cli-admin</a></li><li class="dropdown-subitem"><a href="/blog/skills/vue/vue3-webpack5-admin.html" class="nav-link">vue3-webpack5-admin</a></li><li class="dropdown-subitem"><a href="/blog/project/mono-react-project.html" class="nav-link">teach-react-mono</a></li></ul></li><li class="dropdown-item"><h4>移动端</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/blog/project/mobile-h5/" class="nav-link">微信h5</a></li><li class="dropdown-subitem"><a href="/blog/project/mini-program/" class="nav-link">微信小程序</a></li><li class="dropdown-subitem"><a href="/blog/project/mobile/" class="nav-link">移动端开发笔记</a></li></ul></li></ul></div></div><div class="nav-item"><a href="/blog/tool/" class="nav-link">其他</a></div><div class="nav-item"><a href="https://github.com/verneyZhou" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="关于" class="dropdown-title"><!----> <span class="title" style="display:;">关于</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/blog/about/" class="nav-link">ME</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>Docker入门学习笔记</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/more/docker-note.html#部署流程发展" class="sidebar-link">部署流程发展</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/more/docker-note.html#虚拟机" class="sidebar-link">虚拟机</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/more/docker-note.html#linux-容器" class="sidebar-link">Linux 容器</a></li><li class="sidebar-sub-header"><a href="/blog/more/docker-note.html#安装虚拟机" class="sidebar-link">安装虚拟机</a></li></ul></li><li><a href="/blog/more/docker-note.html#docker" class="sidebar-link">Docker</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/more/docker-note.html#image镜像" class="sidebar-link">Image镜像</a></li><li class="sidebar-sub-header"><a href="/blog/more/docker-note.html#container容器" class="sidebar-link">Container容器</a></li><li class="sidebar-sub-header"><a href="/blog/more/docker-note.html#repository仓库" class="sidebar-link">Repository仓库</a></li><li class="sidebar-sub-header"><a href="/blog/more/docker-note.html#docker的优点" class="sidebar-link">Docker的优点</a></li><li class="sidebar-sub-header"><a href="/blog/more/docker-note.html#docker-vs-传统虚拟机" class="sidebar-link">Docker vs 传统虚拟机</a></li><li class="sidebar-sub-header"><a href="/blog/more/docker-note.html#docker的安装" class="sidebar-link">Docker的安装</a></li><li class="sidebar-sub-header"><a href="/blog/more/docker-note.html#docker常见命令" class="sidebar-link">Docker常见命令</a></li><li class="sidebar-sub-header"><a href="/blog/more/docker-note.html#基础操作" class="sidebar-link">基础操作</a></li><li class="sidebar-sub-header"><a href="/blog/more/docker-note.html#容器内操作" class="sidebar-link">容器内操作</a></li><li class="sidebar-sub-header"><a href="/blog/more/docker-note.html#docker的使用" class="sidebar-link">Docker的使用</a></li><li class="sidebar-sub-header"><a href="/blog/more/docker-note.html#dockerfile" class="sidebar-link">Dockerfile</a></li><li class="sidebar-sub-header"><a href="/blog/more/docker-note.html#docker-compose-yaml" class="sidebar-link">docker-compose.yaml</a></li><li class="sidebar-sub-header"><a href="/blog/more/docker-note.html#dockerignore" class="sidebar-link">.dockerignore</a></li><li class="sidebar-sub-header"><a href="/blog/more/docker-note.html#例一-使用docker启动一个vite项目" class="sidebar-link">例一：使用Docker启动一个Vite项目</a></li><li class="sidebar-sub-header"><a href="/blog/more/docker-note.html#例二-部署node服务应用" class="sidebar-link">例二：部署Node服务应用</a></li></ul></li><li><a href="/blog/more/docker-note.html#备注" class="sidebar-link">备注</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/more/docker-note.html#收藏" class="sidebar-link">收藏</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/blog/more/docker-note.html#参考" class="sidebar-link">参考</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-0c557b5e><div class="articleInfo" data-v-0c557b5e><ul class="breadcrumbs" data-v-0c557b5e><li data-v-0c557b5e><a href="/blog/" title="首页" class="iconfont icon-home router-link-active" data-v-0c557b5e></a></li> <li data-v-0c557b5e><a href="/blog/categories/?category=more" title="分类" data-v-0c557b5e>more</a></li></ul> <div class="info" data-v-0c557b5e><div title="作者" class="author iconfont icon-touxiang" data-v-0c557b5e><a href="javascript:;" data-v-0c557b5e>阿沐</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-0c557b5e><a href="javascript:;" data-v-0c557b5e>2023-08-05</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABGpJREFUSA3tVVtoXFUU3fvOI53UlmCaKIFmwEhsE7QK0ipFEdHEKpXaZGrp15SINsXUWvBDpBgQRKi0+KKoFeJHfZA+ED9KKoIU2gYD9UejTW4rVIzm0VSTziPzuNu1z507dibTTjL4U/DAzLn3nL3X2o91ziX6f9wMFdh6Jvbm9nNSV0msViVO6tN1Rm7NMu2OpeJ9lWBUTDxrJbYTS0hInuwciu9eLHlFxCLCZEk3MegsJmZ5K/JD6t7FkFdEvGUo1g7qJoG3MHImqRIn8/nzY1K9UPKKiJmtnUqHVE3Gbuay6vJE/N2FEmuxFjW2nUuE0yQXRRxLiTUAzs36zhZvOXJPdX850EVnnLZkB8prodQoM5JGj7Xk2mvC7JB8tG04Ef5PiXtG0UtxupRQSfTnBoCy554x18yJHI6I+G5Eru4LHmPJZEQsrvPUbMiA8G/WgMK7w7I+ez7++o2ANfbrjvaOl1tFMs+htG3IrZH9/hDX1Pr8Tc0UvH8tcX29KzAgIGcEkINyW5BF9x891hw6VYqgJHEk0huccS7vh3C6gTiODL+26huuBtbct8eZnqLML8PkxGYpuPZBqtqwkSjgc4mB5gbgig5i+y0UDK35LMxXisn9xQtK+nd26gTIHsHe/oblK/b29fUmN/8Y+9jAQrnBp56m1LcDlDp9irKTExSKduXJVWSqdBMA08pEJnEIOB3FPPMybu/oeV8zFeYN3xx576Q6RH+VmplE4ncQV5v+5rzSoyOU7PuEAg8g803PwBJ0CExno/jcMbN8tONYeOmHiuUNryvm3fRUy4tMPVLdAGkUhNWuggGrJcXPv+ouCjz0MKUHz1J2/E8IC9nqTabcxgaBYM0hPhD5Y65FsbxRQKxCQrDjDctW7PUM3HuZunFyifSAqEfuzCp48Il24luWUWZoyJCaPR82jE0+kFA643wRFVni4RYSq3ohJO2pZ7B5dO4xkDWbEpossJPLSrPjYID8rS2UHTlvyNxqIGsg674XJJ7vnh5L7PNwC4hh2sjCI96mzszOTpxLF0T7l88Yz7lAuK6OnL8gXLOnTvpzSb22YG8W7us3jSebFHeeqnXRG1vt+MoUM84LQIBmMsCTAcOauTh0T0l0neQK7m2bLMt2mGxU3HYssS0J2cdv5wljlPsrIuZLAG/2DOZIXgCYT8uMGZN+e2kSirfxZOPCsC0f24nTZzspnVn9VePS1Z5vubmAGGXG8ZFno9Hel0yfA5ZPhF7Dh972BQJ2qCpgH67lmWtBYbvk6sz02wjky2vXyz0XErP/kFB619js1BtwfOV4OPRqOQBjy3Qbk18vigUPPSD5ceHnwck7W9bhAqZdd7SuG7w4/P2F/GaJh8c7e9qgow+Q7cGBo+98WsLkuktFqiZabtXuQTu/Y5ETbR0v7tNSFnvrmu6pjdoan2KjMu8q/Hmj1EfCO2ZGfEIbIXKUlw8qaX9/b2oeSJmFksSeT/Fn0V3nSypChh4Gjh74ybO9aeZ/AN2dwciu2/MhAAAAAElFTkSuQmCC">Docker入门学习笔记<!----></h1> <!----> <div class="theme-vdoing-content content__default"><h1 id="docker入门学习笔记"><a href="#docker入门学习笔记" class="header-anchor">#</a> Docker入门学习笔记</h1> <blockquote><p>从事前端开发这么几年来，过去一直专注于项目的业务开发，对于项目编译完成后的部署流程一直处于一知半解的状态，而Docker作为这几年项目自动化部署的热门技术，我一直以来都想好好花时间学习一下~ 所以最近花了一些时间整理了这篇笔记，梳理下我的Docker入门之路~</p></blockquote> <h2 id="部署流程发展"><a href="#部署流程发展" class="header-anchor">#</a> 部署流程发展</h2> <ol><li>无虚拟机时代</li></ol> <p>第一步肯定是先要准备一台<strong>物理服务器</strong>，然后在物理服务器上安装一个<strong>操作系统</strong>(Operating System)，有了操作系统之后，便在操作系统上安装运行我们的<strong>应用程序</strong>。</p> <div class="custom-block warning"><p class="custom-block-title">缺点</p> <ul><li>部署非常慢：因为我们得先准备硬件服务器，接着还要安装操作系统，然后再部署应用程序，而且应用程序还有很多的依赖软件，所以这个过程是比较慢的。</li> <li>成本非常高：主要是物理器成本太高，即使是部署一个简单的应用，也需要一台服务器。</li> <li>资源浪费：如果应用太简单，也容易浪费硬件资源，比如CPU和内存</li></ul></div> <ol start="2"><li>虚拟机部署</li></ol> <p>虚拟机（VM, virtual machine）允许我们在一台物理计算机模拟出多台机器,简单地理解，虚拟化技术就是<strong>在一台物理计算机上，通过中间虚拟软件层Hypervisor隔离CPU、内存等硬件资源，虚拟出多台虚拟服务器</strong>。这样做的话，一台物理服务器便可以安装多个应用程序，达到资源利用的最大化，而且多个应用之间相互隔离。</p> <div class="custom-block tip"><p class="custom-block-title">优点</p> <ul><li>可以把资源分配到不同的虚拟机，达到硬件资源的最大化利用</li> <li>与直接在物理机上部署应用，虚拟机更容易扩展应用。</li> <li>云服务:通过虚拟机虚拟出不同的物理资源，可以快速搭建云服务。</li></ul></div> <ul><li>缺点</li></ul> <blockquote><p>虚拟机的不足之处在于对物理服务器资源的消耗，当我们在物理服务器创建一台虚拟机时，便需要虚拟出一套硬件并在上面运行完整的操作系统，每台虚拟机都占用许多的服务器资源。</p></blockquote> <ol start="3"><li>Docker部署</li></ol> <blockquote><p>Docker 是使用时下很火的 Golang 语言进行开发的，其技术核心是 Linux 内核的 Cgroup,Namespace 和 AUFS 类的 Union FS 等技术，这些技术都是 Linux 内核中早已存在很多年的技术，所以严格来说 Docker 并不是一个完全创新的技术，Docker 通过这些底层的 Linux 技术，对 Linux 进程进行封装隔离，而被隔离的进程也被称为容器，完全独立于宿主机的进程。</p></blockquote> <p>Docker是<strong>容器</strong>技术的一种实现，也是操作系统层面的一种虚拟化，与虚拟机通过一套硬件再安装操作系统完全不同。</p> <p>相对于虚拟机的笨重，Docker则更显得轻量化，因此不会占用太多的系统资源。</p> <h2 id="虚拟机"><a href="#虚拟机" class="header-anchor">#</a> 虚拟机</h2> <p>虚拟机 Virtual Machine 指通过软件模拟的具有完整硬件系统功能的、运行在一个完全隔离环境中的完整计算机系统。在实体计算机中能够完成的工作在虚拟机中都能够实现。</p> <p>VM允许将操作系统安装在仿真的硬件环境中。从本质上讲，它是在你的PC上运行的PC。</p> <blockquote><p>从理论上讲，可以使用你的应用程序及其所有依赖项来创建Linux（或其他）VM。VM只是数据：可以将其复制并在任何实际的Windows，macOS或Linux设备上运行。每个开发人员以及实时服务器都可以运行相同的环境。</p></blockquote> <p>在计算机中创建虚拟机时，需要将实体机的部分硬盘和内存容量作为虚拟机的硬盘和内存容量。每个虚拟机都有独立的 CMOS、硬盘和操作系统，可以像使用实体机一样对虚拟机进行操作。在容器技术之前，业界的网红是虚拟机。虚拟机技术的代表，是 VMWare 和 OpenStack。</p> <div class="custom-block warning"><p class="custom-block-title">缺点</p> <ul><li>VM磁盘映像很大，难以复制</li> <li>单个VM可以自动更新，也可以由单个开发人员更新，因此与其他VM不同步</li> <li>一个VM需要大量的计算资源：它是一个完整的OS，在另一个OS内的仿真硬件上运行。</li></ul></div> <h3 id="linux-容器"><a href="#linux-容器" class="header-anchor">#</a> Linux 容器</h3> <p>由于虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：<strong>Linux 容器（Linux Containers，缩写为 LXC）</strong>。</p> <p><strong>Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。</strong></p> <ol><li>随处运行：容器可以将代码与配置文件和相关依赖库进行打包，从而确保在任何环境下的运行都是一致的。</li> <li>高资源利用率：<strong>容器提供进程级的隔离</strong>，因此可以更加精细地设置 CPU 和内存的使用率，进而更好地利用服务器的计算资源。</li> <li>快速扩展：每个容器都可作为单独的进程予以运行，并且可以共享底层操作系统的系统资源，这样一来可以加快容器的启动和停止效率。</li></ol> <blockquote><p>容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。</p></blockquote> <ul><li>区别</li></ul> <ol><li>虚拟机虽然可以隔离出很多「子电脑」，但占用空间更大，启动更慢。虚拟机软件可能还要花钱，例如VMWare；</li> <li>容器技术不需要虚拟出整个操作系统，只需要虚拟一个小规模的环境，类似「沙箱」；</li> <li>运行空间，虚拟机一般要几 GB 到 几十 GB 的空间，而容器只需要 MB 级甚至 KB 级；</li></ol> <h3 id="安装虚拟机"><a href="#安装虚拟机" class="header-anchor">#</a> 安装虚拟机</h3> <p>跨平台 VM 选项包括<a href="https://www.vmware.com/cn.html" target="_blank" rel="noopener noreferrer">VMware<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>、<a href="https://www.virtualbox.org/" target="_blank" rel="noopener noreferrer">VirtualBox<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>和<a href="https://www.parallels.cn/" target="_blank" rel="noopener noreferrer">Parallels Desktop<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。</p> <p><a href="https://www.oracle.com/virtualization/technologies/vm/downloads/virtualbox-downloads.html" target="_blank" rel="noopener noreferrer">virtualbox官方下载<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <blockquote><p>看自己电脑配置，我选择的 <code>Mac OS X Apple Silicon (Beta 4 Release)</code></p></blockquote> <ul><li><a href="https://zhuanlan.zhihu.com/p/608044681" target="_blank" rel="noopener noreferrer">Parallels Desktop还是VMware Fusion？在Mac上使用Windows<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://www.zhihu.com/question/20677363" target="_blank" rel="noopener noreferrer">Parallels Desktop 和 VMware Fusion 哪个更好用？ 有别的推荐吗？<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <h2 id="docker"><a href="#docker" class="header-anchor">#</a> Docker</h2> <blockquote><p>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。它是目前最流行的 Linux 容器解决方案。</p></blockquote> <p>Docker 相比于传统虚拟机的技术来说先进了不少，具体表现在 <strong>Docker 不是在宿主机上虚拟出一套硬件后再虚拟出一个操作系统，而是让 Docker 容器里面的进程直接运行在宿主机上</strong>（Docker 会做文件、网络等的隔离），这样一来 Docker 会 “体积更轻、跑的更快、同宿主机下可创建的个数更多”。</p> <blockquote><p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。</p></blockquote> <ul><li><a href="https://www.docker.com/get-started/" target="_blank" rel="noopener noreferrer">Docker官网<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul> <p>docker 的<a href="https://docs.docker.com/get-started/overview/#docker-architecture" target="_blank" rel="noopener noreferrer">架构图<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>如下:</p> <img src="/blog/images/more/docker04.svg" width="auto"> <div class="custom-block tip"><p class="custom-block-title">提示</p> <ul><li><code>docker client</code>: 即 docker 命令行工具</li> <li><code>docker host</code>: 宿主机，<code>docker daemon</code> 的运行环境服务器</li> <li><code>docker daemon</code>: docker 的守护进程，<code>docker client</code> 通过命令行与 <code>docker daemon</code> 交互</li> <li><code>image</code>: 镜像，可以理解为一个容器的模板，通过一个镜像可以创建多个容器</li> <li><code>container</code>: 最小型的一个操作系统环境，可以对各种服务以及应用容器化，是镜像的运行实例</li> <li><code>registry</code>: 镜像仓库，存储大量镜像，可以从镜像仓库拉取和推送镜像</li></ul></div> <p>Docker 技术的三大核心概念，分别是：<strong>镜像 Image、容器 Container、仓库 Repository</strong>。</p> <p>Docker本质上是一个运行在Linux操作系统上的应用，而Linux操作系统分为内核和用户空间，无论是Centos还是Ubuntu，都是在启动内核之后，通过挂载<code>Root文件系统</code>来提供用户空间的,而<strong>Docker镜像就是一个Root文件系统</strong>。</p> <h3 id="image镜像"><a href="#image镜像" class="header-anchor">#</a> Image镜像</h3> <p>Docker 的镜像可以简单的类比为电脑装系统用的系统盘，包括操作系统，以及必要的软件。例如，一个镜像可以包含一个完整的 <code>centos</code> 操作系统环境，并安装了 <code>Nginx</code> 和 <code>Tomcat</code> 服务器。</p> <blockquote><p>注意的是，镜像是只读的。这一点也很好理解，就像我们刻录的系统盘其实也是可读的。我们可以使用 <code>docker images</code> 来查看本地镜像列表。</p></blockquote> <blockquote><p>镜像是一个可执行包，其包含运行应用程序所需的代码、运行时、库、环境变量和配置文件，<strong>容器是镜像的运行时实例</strong>。镜像是一个静态的概念，不包含任何动态数据，其内容在构建之后也不会被改变。</p></blockquote> <p>开发者可以将自己的应用打包在自己的镜像里面，然后迁移到其他平台的 Docker 中。镜像中可以存放你自己自定义的运行环境，文件，代码，设置等等内容，再也不用担心环境造成的运行问题。镜像共享运行机器的系统内核。</p> <blockquote><p>同样， Docker 也支持跨平台。你的镜像也可以加载在 Windows 和 Linux，实现快速运行和部署。</p></blockquote> <h3 id="container容器"><a href="#container容器" class="header-anchor">#</a> Container容器</h3> <p>Docker 的容器可以简单理解为提供了系统硬件环境，它是真正跑项目程序、消耗机器资源、提供服务的东西。例如，我们可以暂时把容器看作一个 Linux 的电脑，它可以直接运行。那么，容器是基于镜像启动的，并且每个容器都是相互隔离的。注意的是，容器在启动的时候基于镜像创建一层可写层作为最上层。我们可以使用 <code>docker ps -a</code> 查看本地运行过的容器。</p> <blockquote><p>容器的存在离不开镜像的支持，他是镜像运行时的一个载体（类似于实例和类的关系）。依托 Docker 的虚拟化技术，给容器创建了独立的端口、进程、文件等“空间”，Container 就是一个与宿机隔离 “容器”。容器可宿主机之间可以进行 port、volumes、network 等的通信。</p></blockquote> <p>Docker的镜像是用于生成容器的模板，镜像分层的，镜像与容器的关系，就是面向对象编程中类与对象的关系，我们定好每一个类，然后使用类创建对象，对应到Docker的使用上，则是构建好每一个镜像，然后使用镜像创建我们需要的容器。</p> <blockquote><p>容器就是一个不错的解决方案，容器能成为开发与运维之间沟通的语言，因为容器就像一个集装箱一样，提供了软件运行的最小化环境，将应用与其需要的环境一起打包成为镜像，便可以在开发与运维之间沟通与传输。</p></blockquote> <div class="custom-block tip"><p class="custom-block-title">注：</p> <p>Docker 的镜像就是它的文件系统，一个镜像可以放在另外一个镜像的上层，那么位于下层的就是它的父镜像。所以，Docker 会存在很多镜像层，每个镜像层都是只读的，并且不会改变。当我们创建一个新的容器时，Docker 会构建出一个镜像栈，并在栈的最顶层添加一个读写层。</p></div> <img src="/blog/images/more/docker03.png" width="auto"> <h3 id="repository仓库"><a href="#repository仓库" class="header-anchor">#</a> Repository仓库</h3> <blockquote><p>构建镜像完成之后，可以在本地运行镜像，生成容器，但如何在更多的服务器运行镜像呢？很明显，这时候我们需要一个可以让我们集中存储和分发镜像的服务，就像Github可以让我们自己存储和分发代码一样。</p></blockquote> <p><strong>Docker 的仓库用于存放镜像</strong>。这一点，和 Git 非常类似。我们可以从中心仓库下载镜像，也可以从自建仓库下载。同时，我们可以把制作好的镜像 <code>commit</code> 到本地，然后 <code>push</code> 到远程仓库。</p> <p>Docker Hub就是Docker提供用于存储和分布镜像的官方Docker Registry，也是默认的Registry，前面我们使用<code>docker pull</code>命令便从<code>Docker Hub</code>上拉取镜像。</p> <blockquote><p>仓库分为公开仓库和私有仓库，最大的公开仓库是官方仓库<a href="https://hub.docker.com" target="_blank" rel="noopener noreferrer"> Dock Hub<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>，国内的公开仓库也有很多选择，例如<a href="https://cr.console.aliyun.com/" target="_blank" rel="noopener noreferrer">阿里云<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>等。</p></blockquote> <h3 id="docker的优点"><a href="#docker的优点" class="header-anchor">#</a> Docker的优点</h3> <p>Docker 的优势在于 快速，轻量，灵活。开发者可以制作一个自己自定义的镜像，也可以使用官方或者其他开发者的镜像来启动一个服务。通过将镜像创建为容器，容器之间相互隔离资源和进程不冲突。但硬件资源又是共享的。 创建的镜像也可以通过文件快速分享，也可以上传到镜像库进行存取和管理。同时 Docker 的镜像有 <code>分层策略</code> ，每次对镜像的更新操作，都会堆叠一个新层。当你拉取 / 推送新版本镜像时，只推送 / 拉取修改的部分。大大加快了镜像的传输效率。</p> <blockquote><p>Docker 贯穿 CI/CD 中整个流程。作为应用服务的载体有着非常重要的地位。我们可以使用 Docker 将应用打包成一个镜像，交给 Kubernetes 去部署在目标服务集群。并且可以将镜像上传到自己的镜像仓库，做好版本分类处理。</p></blockquote> <p>Docker 技术使用 Linux 内核和内核功能（例如 Cgroups 和 namespaces）来分隔进程，以便各进程相互独立运行。</p> <ol><li><strong>多环境的部署切换</strong></li></ol> <p>业务开发中往往需要区分开发环境与线上环境，利用 Docker 能<strong>原封不动的将开发环境中的代码与环境原封不动无污染的迁移到线上环境</strong>，配合一定的自动化流程即可实现自动的发布。</p> <ol start="2"><li><strong>前端云构建</strong></li></ol> <p>因为 <code>node_modules</code> 的蛋疼问题，同一个仓库下不同人开发往往会遇到不同的人使用不同的 包版本 且自己根本不知道与别人不一样，最终导致发布之后产生线上问题。利用 Docker 可以在云端新建容器，远程 <strong>无污染、低成本</strong> 构建代码，实现 <strong>不同人用的一定是同一个版本</strong>。</p> <ol start="3"><li><strong>复杂环境一键配置</strong></li></ol> <p>某些场景下可能会配一些超级复杂的环境，这个时候可以利用 Docker 对环境配置做封装，直接生成镜像，让大家低成本使用。</p> <h3 id="docker-vs-传统虚拟机"><a href="#docker-vs-传统虚拟机" class="header-anchor">#</a> Docker vs 传统虚拟机</h3> <p>Docker 相比于传统虚拟机的技术来说先进了不少，具体表现在 Docker 不是在宿主机上虚拟出一套硬件后再虚拟出一个操作系统，而是让 Docker 容器里面的进程直接运行在宿主机上（Docker 会做文件、网络等的隔离），这样一来 Docker 会 “体积更轻、跑的更快、同宿主机下可创建的个数更多”。</p> <p>Docker是在操作系统进程层面的隔离，而虚拟机是在物理资源层面的隔离，两者完全不同。</p> <table><thead><tr><th>特性</th> <th>Docker</th> <th>虚拟机</th></tr></thead> <tbody><tr><td>启动速度</td> <td>秒级</td> <td>分钟级</td></tr> <tr><td>交付/部署</td> <td>开发、测试、生产环境一致</td> <td>无成熟体系</td></tr> <tr><td>性能</td> <td>近似物理机</td> <td>性能损耗大</td></tr> <tr><td>体量</td> <td>极小（MB）</td> <td>较大（GB）</td></tr> <tr><td>系统支持量</td> <td>单机支持上千个容器</td> <td>一般为几十个</td></tr> <tr><td>迁移/扩展</td> <td>跨平台，可复制</td> <td>较为复杂</td></tr></tbody></table> <p><strong>Q: Docker 轻量级的原因？</strong></p> <blockquote><p>当我们请求 Docker 运行容器时，Docker 会在计算机上设置一个资源隔离的环境。然后将打包的应用程序和关联的文件复制到 Namespace 内的文件系统中，此时环境的配置就完成了。之后 Docker 会执行我们预先指定的命令，运行应用程序。</p></blockquote> <blockquote><p>注意：镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p></blockquote> <p><strong>Q:  Docker 如何在 macOS 或 Windows 上运行？</strong></p> <blockquote><p>由于 Namespace 和 Cgroups 功能仅在 Linux 上可用，因此容器无法在其他操作系统上运行。那么 Docker 如何在 macOS 或 Windows 上运行？ Docker 实际上使用了一个技巧，并在非 Linux 操作系统上安装 Linux 虚拟机，然后在虚拟机内运行容器。</p></blockquote> <p><strong>Q: 为什么要使用Docker?</strong></p> <blockquote><p>例如，原来我们存在三个环境：开发（日常）环境、测试环境、生产环境。这里，我们对于每个环境都需要部署相同的软件、脚本和运行程序。事实上，对于启动脚本内容都是一致的，但是没有统一维护，经常会出问题。此外，对于运行程序而言，如果所依赖的底层运行环境不一致，也会造成困扰和异常。</p></blockquote> <blockquote><p>现在，我们通过引入 Docker 之后，我们只需要维护一个 Docker 镜像。换句话说，<strong>多套环境，一个镜像，实现系统级别的一次构建到处运行</strong>。此时，我们把运行脚本标准化了，把底层软件镜像化了，然后对于相同的将要部署的程序实行标准化部署。因此，Docker 为我们提供了一个标准化的运维模式，并固化运维步骤和流程。</p></blockquote> <blockquote><p>通过这个流程的改进，我们更容易实现 DevOps 的目标，因为我们的镜像生成后可以跑在任何系统，并快速部署。此外，使用 Docker 的很大动力是基于 Docker 实现弹性调度，以更充分地利用机器资源，节省成本。</p></blockquote> <h3 id="docker的安装"><a href="#docker的安装" class="header-anchor">#</a> Docker的安装</h3> <ol><li><p>注册账号：<a href="https://hub.docker.com/" target="_blank" rel="noopener noreferrer">hub.docker.com<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li> <li><p>安装：<a href="https://docs.docker.com/desktop/install/mac-install/" target="_blank" rel="noopener noreferrer">Install Docker Desktop on Mac<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li></ol> <blockquote><p>安装完后在终端输入<code>docker</code>，展示使用说明，或输入<code>docker -v</code>展示版本信息，则表示 <code>docker</code> 安装成功~</p></blockquote> <h3 id="docker常见命令"><a href="#docker常见命令" class="header-anchor">#</a> Docker常见命令</h3> <p><a href="https://docs.docker.com/engine/reference/commandline/cli/" target="_blank" rel="noopener noreferrer">Use the Docker command line<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <h4 id="基础操作"><a href="#基础操作" class="header-anchor">#</a> 基础操作</h4> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">docker</span> login -u username  <span class="token comment"># 登录 Docker Hub</span>
<span class="token function">docker</span> verion <span class="token comment"># 打印docker的版本信息</span>

<span class="token function">docker</span> images   <span class="token comment"># 列出所有镜像, 或：docker image ls</span>
/**
REPOSITORY              TAG       IMAGE ID       CREATED             SIZE
verneyzhou/nginx-test   v1        110b1afbac5a   About an hour ago   414MB
nginx                   latest    2002d33a54f7   <span class="token number">4</span> weeks ago         192MB
hello-world             latest    b038788ddb22   <span class="token number">3</span> months ago        <span class="token number">9</span>.14kB
 */
<span class="token comment"># REPOSITORY：仓库名称。</span>
<span class="token comment"># TAG： 镜像标签，其中 lastest 表示最新版本。注意的是，一个镜像可以有多个标签，那么我们就可以通过标签来管理有用的版本和功能标签。</span>
<span class="token comment"># IMAGE ID ：镜像唯一ID。</span>
<span class="token comment"># CREATED ：创建时间。</span>
<span class="token comment"># SIZE ：镜像大小。</span>


<span class="token function">docker</span> pull centos  <span class="token comment"># 拉取nginx镜像, 相当于 docker pull centos:latest， 或 docker pull registry.hub.docker.com/centos:latest</span>

<span class="token comment"># docker pull命令的完整写法如下：</span>
<span class="token function">docker</span> pull <span class="token punctuation">[</span>选项<span class="token punctuation">]</span> <span class="token punctuation">[</span>Docker Registry 地址<span class="token punctuation">[</span>:端口号<span class="token punctuation">]</span>/<span class="token punctuation">]</span>仓库名<span class="token punctuation">[</span>:标签<span class="token punctuation">]</span>
<span class="token comment"># 拉取一个镜像，需要指定Docker Registry的地址和端口号，默认是Docker Hub，还需要指定仓库名和标签，仓库名和标签唯一确定一个镜像，而标签是可能省略，如果省略，则默认使用latest作为标签名，另外，仓库名则由作者名和软件名组成。</span>
<span class="token function">docker</span> pull mysql/mysql-server:latest  <span class="token comment"># 拉取非官方的第三方镜像，则需要指定完整仓库名</span>


<span class="token function">docker</span> image <span class="token function">rm</span> image_name/image_id <span class="token comment">#  删除镜像，image_name表示镜像名，image_id表示镜像id</span>
<span class="token function">docker</span> rmi image_name/image_id <span class="token comment"># 删除镜像快捷命令</span>

<span class="token function">docker</span> inspect image_name  <span class="token comment"># 查看镜像信息</span>

<span class="token function">docker</span> build -t username/image_name:tag_name  <span class="token comment"># 构建 Docker 镜像</span>
<span class="token function">docker</span> push username/image_name  <span class="token comment">#  要将镜像推送到 Docker Hub</span>



<span class="token comment"># 容器相关</span>

<span class="token comment"># docker create [OPTIONS] IMAGE [COMMAND] [ARG...]： 通过镜像去创建一个容器，同时吐出容器 id</span>
<span class="token function">docker</span> create --name containerName ubuntu:18.04
<span class="token comment"># docker run [OPTIONS] [imageName][tag] [COMMAND] [ARG...]</span>
<span class="token function">docker</span> run -it --name containerName ubuntu:18.04 /bin/bash <span class="token comment"># 创建并运行一个容器，然后进入该容器</span>
<span class="token comment"># docker run 等于  docker create + docker start</span>

<span class="token function">docker</span> start container_id  <span class="token comment"># 启动一个已经停止运行的容器, container_id表示容器的id; Docker 容器重启后会沿用 docker run 命令指定的参数来运行</span>
<span class="token function">docker</span> stop container_id <span class="token comment"># 停止正在运行的容器, container_id表示容器的id</span>
<span class="token function">docker</span> restart container_id   <span class="token comment"># 重启一个容器</span>

<span class="token function">docker</span> <span class="token function">ps</span> -a  <span class="token comment"># 查看本地所有容器 </span>
<span class="token function">docker</span> container <span class="token function">ls</span>  <span class="token comment"># 查看运行中的镜像，或： docker ps</span>

<span class="token function">docker</span> container <span class="token function">rm</span> container_id  <span class="token comment"># 删除容器（运行中的容器，应该先停止，再删除）, container_id表示容器id,通过docker ps可以看到容器id</span>
<span class="token comment"># docker rm container_id # 同上</span>
<span class="token function">docker</span> <span class="token function">rm</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">docker</span> <span class="token function">ps</span> -q<span class="token variable">)</span></span>  <span class="token comment"># 删除所有容器</span>
<span class="token function">docker</span> container prune <span class="token comment"># 删除所有退出的容器</span>


<span class="token function">docker</span> <span class="token builtin class-name">exec</span> -it container_id <span class="token builtin class-name">command</span> <span class="token comment"># 进入容器,container_id表示容器的id,command表示linux命令,如 /bin/bash</span>
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> -it c40251c943ff <span class="token function">sh</span>  <span class="token comment"># 进入容器c40251c943ff，并打开一个 shell</span>
<span class="token function">whoami</span>  <span class="token comment"># 进入容器后可查看当前用户，默认为root</span>
<span class="token builtin class-name">exit</span> <span class="token comment"># 退出关闭容器</span>




<span class="token comment"># 其他</span>

<span class="token function">docker</span> port container_id  <span class="token comment"># 查看容器端口信息</span>
<span class="token function">docker</span> stats container_id  <span class="token comment"># 查看容器资源占用</span>
<span class="token function">docker</span> logs container_id  <span class="token comment"># 查看正在运行的容器的日志,比如看看为什么没有运行起来、为什么报错了、谁来访问过了等等</span>
<span class="token function">docker</span> container <span class="token function">cp</span> <span class="token punctuation">[</span>containID<span class="token punctuation">]</span>:<span class="token punctuation">[</span>/path/to/file<span class="token punctuation">]</span> <span class="token builtin class-name">.</span>  <span class="token comment"># 从正在运行的 Docker 容器里面，将文件拷贝到本机当前目录</span>


</code></pre></div><ol><li><code>docker run</code>流程：</li></ol> <ul><li>Docker首先在本机中寻找该镜像  <code>=&gt;</code> 如果没有安装 <code>=&gt;</code> Docker 在 Docker Hub 上查找该镜像 <code>=&gt;</code> 并拉取下载安装到本机 <code>=&gt;</code> 最后 Docker 创建一个新的容器并启动该程序</li> <li>第二次执行  docker run 时  <code>=&gt;</code> Docker 在本机中已经安装该镜像  <code>=&gt;</code> Docker 会直接创建一个新的容器并启动该程序</li></ul> <ol start="2"><li><code>docker stop</code> 和 <code>docker kill</code> 略有不同，<code>docker stop</code> 发送 <code>SIGTERM</code> 信号，然后过一段时间再发出 <code>SIGKILL</code> 信号; 而 <code>docker kill</code> 是直接发送 <code>SIGKILL</code> 信号</li></ol> <h4 id="容器内操作"><a href="#容器内操作" class="header-anchor">#</a> 容器内操作</h4> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token comment"># 在容器内安装node, 跟在本地和云服务器上安装node差不多~</span>
<span class="token function">apt-get</span> update
<span class="token function">apt-get</span> <span class="token function">install</span> <span class="token function">wget</span>
<span class="token function">wget</span> -qO- https://raw.githubusercontent.com/creationix/nvm/v0.33.8/install.sh <span class="token operator">|</span> <span class="token function">bash</span>
<span class="token comment"># 安装完之后可能当前 session 读不到 nvm 命令，可以 exit 之后再进入中终端环境</span>
nvm <span class="token function">install</span> <span class="token number">8.0</span>.0
<span class="token function">node</span> -v


<span class="token comment"># commit 容器，创建新镜像</span>





<span class="token comment"># push 镜像到 docker hub</span>



</code></pre></div><ul><li>来自网友整理的Docker命令图谱：</li></ul> <img src="/blog/images/more/docker02.png" width="auto"> <h3 id="docker的使用"><a href="#docker的使用" class="header-anchor">#</a> Docker的使用</h3> <blockquote><p><a href="https://hub.docker.com/" target="_blank" rel="noopener noreferrer">DockerHub<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> 等网站都提供了众多镜像，一般情况下我们都会从它那找个镜像作为基础镜像，然后再进行我们的后续操作。</p></blockquote> <p><a href="https://docs.docker.com/get-started/overview/" target="_blank" rel="noopener noreferrer">Docker 新手引导<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <ul><li>搭建一个搭建 Web 服务器</li></ul> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">docker</span> run -p <span class="token number">8689</span>:80 --name web -i -t centos /bin/bash <span class="token comment"># 拉取 centos 镜像</span>
<span class="token comment"># -i 选项告诉 Docker 容器保持标准输入流对容器开放，即使容器没有终端连接</span>
<span class="token comment"># -t 选项告诉 Docker 为容器分配一个虚拟终端，以便于我们接下来安装 Nginx 服务器</span>
<span class="token comment"># --rm：当停止容器时自动清除容器</span>
<span class="token comment"># Docker 还支持输入 -d 选项告诉 Docker 在后台运行容器的守护进程</span>
<span class="token comment"># --name web 选项告诉 Docker 创建一个名称是 web 的容器</span>
<span class="token comment"># 通过 -p 8689:80 告诉 Docker 8689 端口是对外开放的端口，80 端口对外开放的端口映射到容器里的端口号</span>
<span class="token function">rpm</span> -ivh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm <span class="token comment"># 安装 nginx 源</span>
yum <span class="token function">install</span> -y nginx  <span class="token comment"># 安装nginx</span>
<span class="token function">whereis</span> nginx <span class="token comment"># 查看安装的路径</span>
nginx <span class="token comment"># 运行nginx</span>
<span class="token comment"># 之后浏览器访问 http://localhost:8689/ 就可以了~</span>

<span class="token function">docker</span> stop web <span class="token comment"># 关闭web服务器</span>
<span class="token function">docker</span> start web <span class="token comment"># 重启web服务器</span>
</code></pre></div><ul><li>构建一个 nginx 服务器</li></ul> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">docker</span> pull nginx <span class="token comment"># 拉取 nginx 镜像</span>
<span class="token function">docker</span> run -p <span class="token number">8753</span>:80 -d --name nginx-test01 nginx <span class="token comment"># 新建 nginx-test01 容器，并运行</span>
<span class="token comment"># 之后浏览器访问 http://localhost:8753/ 即可</span>
</code></pre></div><h3 id="dockerfile"><a href="#dockerfile" class="header-anchor">#</a> Dockerfile</h3> <p>Dockerfile 文件是一个文本文件，用来配置 image。Docker 根据 该文件生成二进制的 image 文件。</p> <blockquote><p>Docker 构建镜像有两种方式，一种方式是使用 <code>docker commit</code> 命令，另外一种方式使用 <code>docker build</code> 命令和 <code>Dockerfile</code> 文件。其中，不推荐使用 <code>docker commit</code> 命令进行构建，因为它没有使得整个流程标准化，因此，在企业的中更加推荐使用 <code>docker build</code> 命令和 <code>Dockerfile</code> 文件来构建我们的镜像。我们使用 <code>Dockerfile</code> 文件可以让构建镜像更具备可重复性，同时保证启动脚本和运行程序的标准化。</p></blockquote> <p><a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener noreferrer">Dockerfile reference<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <ul><li>一个例子：构建我的镜像</li></ul> <ol><li>构建<code>Dockerfile</code>文件：</li></ol> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">mkdir</span> docker-test
<span class="token builtin class-name">cd</span> docker-test
<span class="token function">touch</span> Dockerfile
</code></pre></div><ol start="2"><li>编写<code>Dockerfile</code> 文件：</li></ol> <div class="language-sh extra-class"><pre class="language-sh"><code>FROM centos:7 <span class="token comment">#  Dockerfile 必须要的第一步，它会从一个已经存在的镜像运行一个容器，换句话说，Docker 需要依赖于一个基础镜像进行构建。这里，我们指定 centos 作为基础镜像，它的版本是 7 (CentOS 7)</span>
MAINTAINER VerneyZhou <span class="token string">&quot;VerneyZhou@163.com&quot;</span> <span class="token comment"># 指定作者和邮箱</span>
<span class="token comment"># 执行两个 RUN 指令进行 Nginx 的下载安装</span>
RUN <span class="token function">rpm</span> -ivh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm <span class="token comment"># 安装 Nginx 源</span>
RUN yum <span class="token function">install</span> -y nginx <span class="token comment"># 安装nginx</span>
EXPOSE <span class="token number">80</span> <span class="token comment"># 暴露 Dokcer 容器的 80 端口</span>
</code></pre></div><ol start="3"><li>最后，通过 <code>docker build</code> 命令进行构建:</li></ol> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">docker</span> build -t<span class="token operator">=</span><span class="token string">&quot;verneyzhou/nginx-test:v1&quot;</span> <span class="token builtin class-name">.</span>
<span class="token comment"># - t 告诉 Docker 镜像的名称和版本。注意的是，如果没有指定任何标签，Docker 将会自动为镜像设置一个 lastest 标签</span>
<span class="token comment"># 最后还有一个 . 是为了让 Docker 到当前本地目录去寻找 Dockerfile 文件</span>
</code></pre></div><blockquote><p>注意的是，Docker 会在每一步构建都会将结果提交为镜像，然后将之前的镜像层看作缓存，因此我们重新构建类似的镜像层时会直接复用之前的镜像。如果我们需要跳过，可以使用 <code>--no-cache</code> 选项告诉 Docker 不进行缓存。</p></blockquote> <p>构建成功后，通过 <code>docker scout quickview</code> 可以查看：</p> <div class="language-sh extra-class"><pre class="language-sh"><code>➜  docker-test <span class="token function">docker</span> scout quickview
INFO New version <span class="token number">0.22</span>.3 available <span class="token punctuation">(</span>installed version is <span class="token number">0.16</span>.1<span class="token punctuation">)</span>
    ✓ SBOM of image already cached, <span class="token number">188</span> packages indexed

  Your image  verneyzhou/nginx-test  │    1C    28H    68M    22L     <span class="token number">2</span>?   
  Base image  centos:7               │    1C    11H    30M    11L          

What's Next?
  Learn <span class="token function">more</span> about vulnerabilities → <span class="token function">docker</span> scout cves verneyzhou/nginx-test

➜  docker-test 
</code></pre></div><ol start="4"><li>将镜像推送到远程仓库 Docker Hub:</li></ol> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">docker</span> login <span class="token comment"># 登录docker</span>
<span class="token function">docker</span> push verneyzhou/nginx-test:v1
<span class="token comment"># docker push [OPTIONS] NAME[:TAG] ，其中，NAME 是 verneyzhou/nginx-test，TAG 是 v1</span>
</code></pre></div><p>推送成功后，就可以在<a href="https://hub.docker.com/u/verneyzhou" target="_blank" rel="noopener noreferrer">https://hub.docker.com/u/verneyzhou<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>看到了；或者通过<code>docker iamges</code>、在<code>Docker Desktop</code>上，都能看到~</p> <blockquote><p>推送 Docker Hub 速度很慢，也可以使用国内的仓库，比如<a href="https://cr.console.aliyun.com/cn-hangzhou/instances" target="_blank" rel="noopener noreferrer">阿里云<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></blockquote> <ul><li>网上找的别人整理的<code>Dockerfile</code>命令：</li></ul> <img src="/blog/images/more/docker01.png" width="auto"> <ol><li><code>RUN 、 CMD 、 ENTRYPOINT</code>  三个指令的用途非常相识，不同在于，RUN 指令是在容器被构建时运行的命令，而<code>CMD 、 ENTRYPOINT</code> 是启动容器时执行 <code>shell</code> 命令，而 RUN 会被 <code>docker run</code> 命令覆盖，但是 <code>ENTRYPOINT</code> 不会被覆盖。</li></ol> <blockquote><p><code>RUN</code> 命令在 <code>image</code> 文件的构建阶段执行，执行结果都会打包进入 <code>image</code> 文件；<code>CMD</code> 命令则是在容器启动后执行。另外，一个 <code>Dockerfile</code> 可以包含多个 RUN 命令，但是只能有一个 CMD 命令。</p></blockquote> <ol start="2"><li><p><code>ADD 、 COPY</code> 指令用法一样，唯一不同的是 ADD  支持将归档文件（<code>tar, gzip, bzip2, etc</code>）做提取和解压操作。注意的是，COPY 指令需要复制的目录一定要放在 Dockerfile 文件的同级目录下。</p></li> <li><p>指定了 <code>CMD</code> 命令以后，<code>docker container run</code>命令就不能附加命令了（比如前面的<code>/bin/bash</code>），否则它会覆盖 CMD 命令。</p></li></ol> <h3 id="docker-compose-yaml"><a href="#docker-compose-yaml" class="header-anchor">#</a> docker-compose.yaml</h3> <blockquote><p>在 <code>docker compose v2</code> 中，使用了 <code>docker compose</code> 命令去替代了 <code>docker-compose</code> 命令，可以通过 <code>docker compose version</code> 查看版本号。</p></blockquote> <div class="language-sh extra-class"><pre class="language-sh"><code>$ <span class="token function">docker</span> compose version
Docker Compose version v2.6.0

<span class="token comment"># 使用 docker compose ls，可列出系统全局有多少容器是根据 docker compose 启动，比 v1 版本方便很多</span>
$ <span class="token function">docker</span> compose <span class="token function">ls</span>
NAME                STATUS              CONFIG FILES
cra-deploy          running<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>          /home/train/Documents/cra-deploy/domain.docker-compose.yaml
traefik             running<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>          /home/train/Documents/traefik/docker-compose.yml
</code></pre></div><ul><li>在当前目录，新建配置文件为 <code>docker-compose.yaml</code>:</li></ul> <div class="language-sh extra-class"><pre class="language-sh"><code>version: <span class="token string">&quot;3&quot;</span> <span class="token comment"># 表示该 Docker-Compose 文件使用的版本为3</span>
services:
    nginx:
        image: nginx:latest
        container_name: vue-crayon
        volumes:
            - ./dist:/usr/share/nginx/html
            - ./configs/conf.d:/etc/nginx/conf.d
        ports:
            - <span class="token string">&quot;80:80&quot;</span>
        networks:
            - crayonnet
        restart: on-failure
networks:
    crayonnet:
</code></pre></div><blockquote><p>此时可通过 <code>docker compose up</code> 启动容器。</p></blockquote> <h3 id="dockerignore"><a href="#dockerignore" class="header-anchor">#</a> .dockerignore</h3> <p>COPY命令将所有应用程序文件从主机目录复制到Docker镜像，通常情况下不需要复制所有文件，这个时候可以通过 <code>.dockerignore</code> 来定义不需要复制的文件或者文件夹。</p> <div class="language-sh extra-class"><pre class="language-sh"><code>Dockerfile

.git
.gitignore
.config

.npm
.vscode
node_modules
package-lock.json
README.md
</code></pre></div><h3 id="例一-使用docker启动一个vite项目"><a href="#例一-使用docker启动一个vite项目" class="header-anchor">#</a> 例一：使用Docker启动一个Vite项目</h3> <ol><li>新建vite项目</li></ol> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">npm</span> create vite@latest
<span class="token comment"># 按提示操作即可，随便新建一个新的vite项目即可~</span>

<span class="token builtin class-name">cd</span> docker-vite-test
nvm use v16 <span class="token comment"># node使用 v16+</span>
<span class="token function">npm</span> <span class="token function">install</span>
<span class="token function">npm</span> run dev
</code></pre></div><blockquote><p>安装依赖，启动项目后，本地会正常运行~</p></blockquote> <ol start="2"><li>新增打包配置</li></ol> <ul><li><p>项目打包：<code>npm run build</code>，默认打包后会生成<code>dist</code>文件；</p></li> <li><p>在根目录下新建 <code>Nginx</code> 配置文件：<code>touch default.conf</code>，添加如下代码：</p></li></ul> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token comment"># default.conf</span>

server <span class="token punctuation">{</span>
    listen       <span class="token number">80</span><span class="token punctuation">;</span>
    server_name  localhost<span class="token punctuation">;</span>

    <span class="token comment">#charset koi8-r;</span>
    access_log  /var/log/nginx/host.access.log  main<span class="token punctuation">;</span>
    error_log  /var/log/nginx/error.log  error<span class="token punctuation">;</span>

    location / <span class="token punctuation">{</span>
        root   /usr/share/nginx/html<span class="token punctuation">;</span>
        index  index.html index.htm<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    error_page   <span class="token number">500</span> <span class="token number">502</span> <span class="token number">503</span> <span class="token number">504</span>  /50x.html<span class="token punctuation">;</span>
    location <span class="token operator">=</span> /50x.html <span class="token punctuation">{</span>
        root   /usr/share/nginx/html<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>新建 <code>Dockerfile</code>文件：</li></ul> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token comment"># 在项目根目录下执行：</span>
<span class="token function">touch</span> Dockerfile

<span class="token function">docker</span> pull nginx <span class="token comment"># 拉取最新的nginx镜像</span>
</code></pre></div><ul><li>添加 <code>Dockerfile</code>配置：</li></ul> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token comment"># Dockerfile</span>

FROM nginx  <span class="token comment"># 指定该镜像是基于 nginx:latest 镜像而构建的</span>

<span class="token comment"># 将项目根目录下 dist 文件夹中的所有文件复制到镜像中 /usr/share/nginx/html/ 目录下</span>
COPY dist/ /usr/share/nginx/html/
<span class="token comment"># 将 default.conf 复制到 etc/nginx/conf.d/default.conf，用本地的 default.conf 配置来替换 Nginx 镜像里的默认配置。</span>
COPY default.conf /etc/nginx/conf.d/default.conf  
</code></pre></div><ol start="3"><li>构建镜像：</li></ol> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">docker</span> build -t<span class="token operator">=</span><span class="token string">&quot;verneyzhou/docker-vite-test&quot;</span> <span class="token builtin class-name">.</span>
<span class="token comment"># 基于当前目录的 Dockerfile 来构建镜像，并给镜像命名为：verneyzhou/docker-vite-test，并添加默认标签：lastest</span>

<span class="token function">docker</span> image <span class="token function">ls</span> <span class="token operator">|</span> <span class="token function">grep</span> verneyzhou/docker-vite-test <span class="token comment"># 构建成功，查看镜像：</span>
/**
verneyzhou/docker-vite-test   latest    094000583d8c   About an hour ago   192MB
 */
</code></pre></div><blockquote><p>可以看到我们构建了一个192MB的项目镜像；也可以在<code>Docker Desktop</code>上查看~</p></blockquote> <ol start="4"><li>创建容器，并运行</li></ol> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">docker</span> run -d -p <span class="token number">8894</span>:80 --name vite-test-container verneyzhou/docker-vite-test
<span class="token comment"># -d 设置容器在后台运行</span>
<span class="token comment"># -p 表示端口映射，把本机的 8894 端口映射到 container 的 80 端口（这样外网就能通过本机的 8894 端口访问了）。</span>
<span class="token comment"># --name 设置容器名 vite-test-container</span>
<span class="token comment"># verneyzhou/docker-vite-test 是我们上面构建的镜像名字</span>

<span class="token function">docker</span> <span class="token function">ps</span>  <span class="token comment"># 运行成功后，查看运行中的容器信息：</span>
/**
CONTAINER ID   IMAGE                         COMMAND                   CREATED          STATUS          PORTS                  NAMES
6b5c6150db14   verneyzhou/docker-vite-test   <span class="token string">&quot;/docker-entrypoint.…&quot;</span>   <span class="token number">57</span> minutes ago   Up <span class="token number">57</span> minutes   <span class="token number">0.0</span>.0.0:8894-<span class="token operator">&gt;</span><span class="token number">80</span>/tcp   vite-test-container
 */
</code></pre></div><ol start="5"><li>访问项目</li></ol> <p>这时浏览器打开 <code>http://localhost:8894/</code>，就可以看到对应的页面，跟我们前面创建项目的时候看到的界面是一样的；也可以通过：<code>curl -v -i localhost:8894</code> 去查看对应的静态文件；</p> <blockquote><p>这样就说明我们用把项目打包后的文件放在了 docker 创建的的容器里了，并可以通过启动的本地服务进行访问~</p></blockquote> <ol start="6"><li>发布镜像</li></ol> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">docker</span> login <span class="token comment"># 登录镜像，已登录可忽略</span>
<span class="token function">docker</span> push verneyzhou/docker-vite-test <span class="token comment"># 将该镜像推送到 hub.docker 上</span>
</code></pre></div><blockquote><p>推送完成后，就可以在<a href="https://hub.docker.com/" target="_blank" rel="noopener noreferrer">https://hub.docker.com/<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>上搜到你的镜像了~</p></blockquote> <ol start="7"><li>自动化部署</li></ol> <blockquote><p>上面的整个流程中，不管是镜像构建还是容器运行，都是手动去敲命令的，然而，重复的工作都可以被优化。现在使用 <code>sh</code> 脚本来自动化执行整个部署流程。</p></blockquote> <ul><li>sh 脚本文件一般放在 <code>bin</code> 目录下，在 <code>bin</code> 目录下新建文件 <code>setup_for_host.sh</code> 文件：</li></ul> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token comment"># setup_for_host.sh</span>

<span class="token comment"># 构建镜像</span>
<span class="token assign-left variable">image_name</span><span class="token operator">=</span>verneyzhou/docker-vite-test <span class="token comment"># 表示镜像名称</span>
<span class="token assign-left variable">version</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span><span class="token function">date</span> +<span class="token string">'%Y%m%d-%H%M%S'</span><span class="token variable">)</span></span> <span class="token comment"># 表示镜像版本（用时间表示）</span>
<span class="token assign-left variable">contianer_name</span><span class="token operator">=</span>vite-test-container <span class="token comment"># 运行的容器名称</span>
<span class="token assign-left variable">host_port</span><span class="token operator">=</span><span class="token number">8894</span> <span class="token comment"># 本机端口</span>
<span class="token assign-left variable">container_port</span><span class="token operator">=</span><span class="token number">80</span> <span class="token comment"># 运行的容器端口</span>

<span class="token builtin class-name">echo</span> <span class="token string">'docker build...'</span> <span class="token comment"># 构建镜像</span>
<span class="token function">docker</span> build -t <span class="token variable">$image_name</span><span class="token builtin class-name">:</span><span class="token variable">$version</span> <span class="token builtin class-name">.</span>
<span class="token builtin class-name">echo</span> <span class="token string">'docker rm...'</span> <span class="token comment"># 清理同名容器</span>
<span class="token comment"># 如果已经有同名的容器，删除掉</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token string">&quot;<span class="token variable"><span class="token variable">$(</span><span class="token function">docker</span> <span class="token function">ps</span> -aq -f <span class="token assign-left variable">name</span><span class="token operator">=</span>$contianer_name<span class="token variable">)</span></span>&quot;</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
  <span class="token builtin class-name">echo</span> <span class="token string">'docker rm ...'</span>
  <span class="token function">docker</span> <span class="token function">rm</span> -f <span class="token variable">$contianer_name</span>
<span class="token keyword">fi</span>
<span class="token builtin class-name">echo</span> <span class="token string">'docker run...'</span> <span class="token comment"># 启动容器</span>
<span class="token function">docker</span> run -d --name <span class="token variable">$contianer_name</span> -p <span class="token variable">$host_port</span><span class="token builtin class-name">:</span><span class="token variable">$container_port</span> <span class="token variable">$image_name</span><span class="token builtin class-name">:</span><span class="token variable">$version</span>
<span class="token builtin class-name">echo</span> <span class="token string">'Done!'</span>

</code></pre></div><ul><li><p>如果有其他容器占用了<code>8894</code>端口，则需要先删除该容器：<code>docker rm container_id</code></p></li> <li><p>项目根目录执行脚本：</p></li></ul> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">chmod</span> +x bin/setup_host.sh <span class="token comment"># 添加可执行权限</span>
bin/setup_host.sh <span class="token comment"># 执行自动化部署</span>
</code></pre></div><ul><li>其他命令</li></ul> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">docker</span> <span class="token builtin class-name">exec</span> -it 6b5c6150db14 <span class="token function">sh</span> <span class="token comment"># 进入容器, 或 docker exec -it vite-test-container sh</span>
<span class="token builtin class-name">exit</span> <span class="token comment"># 退出容器</span>
<span class="token function">docker</span> stop vite-test-container <span class="token comment"># 退出容器</span>
<span class="token function">docker</span> start vite-test-container <span class="token comment"># 重启容器</span>
</code></pre></div><h3 id="例二-部署node服务应用"><a href="#例二-部署node服务应用" class="header-anchor">#</a> 例二：部署Node服务应用</h3> <ol><li>新建一个node项目：</li></ol> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">mkdir</span> docker-node-test
<span class="token builtin class-name">cd</span> docker-node-test
<span class="token function">npm</span> init -y <span class="token comment"># npm初始化</span>
<span class="token function">npm</span> i express <span class="token comment"># 安装express</span>
<span class="token function">touch</span> server.js <span class="token comment"># 新建server.js文件</span>
</code></pre></div><ul><li><code>server.js</code>添加内容：</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token string">'use strict'</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> express <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'express'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Constants</span>
<span class="token keyword">const</span> <span class="token constant">PORT</span> <span class="token operator">=</span> <span class="token number">8080</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token constant">HOST</span> <span class="token operator">=</span> <span class="token string">'0.0.0.0'</span><span class="token punctuation">;</span>

<span class="token comment">// App</span>
<span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
app<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span> res</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  res<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">'Hello World'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token constant">PORT</span><span class="token punctuation">,</span> <span class="token constant">HOST</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Running on http://</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token constant">HOST</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token constant">PORT</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li><code>package.json</code>中添加命令：</li></ul> <div class="language-json extra-class"><pre class="language-json"><code><span class="token property">&quot;scripts&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token property">&quot;start&quot;</span><span class="token operator">:</span> <span class="token string">&quot;node server.js&quot;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre></div><blockquote><p><code>npm run start</code> 执行看下是否运行正常~</p></blockquote> <p>或者<code>curl -i localhost:8080</code>，查看响应是否正常：</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">curl</span> -i localhost:8080

HTTP/1.1 <span class="token number">200</span> OK
X-Powered-By: Express
Content-Type: text/html<span class="token punctuation">;</span> <span class="token assign-left variable">charset</span><span class="token operator">=</span>utf-8
Content-Length: <span class="token number">11</span>
ETag: W/<span class="token string">&quot;b-Ck1VqNd45QIvq3AZd8XYQLvEhtA&quot;</span>
Date: Sun, 06 Aug <span class="token number">2023</span> <span class="token number">17</span>:25:00 GMT
Connection: keep-alive
Keep-Alive: <span class="token assign-left variable">timeout</span><span class="token operator">=</span><span class="token number">5</span>

Hello World% 
</code></pre></div><ol start="2"><li>添加 <code>.dockerignore</code> 和 <code>Docerkfile</code></li></ol> <ul><li><code>.dockerignore</code>:</li></ul> <div class="language-sh extra-class"><pre class="language-sh"><code>node_modules
npm-debug.log
</code></pre></div><ul><li><code>Docerkfile</code>:</li></ul> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token comment"># 使用更轻量的 node18</span>
FROM node:18-alpine
<span class="token comment"># 创建工作目录 /app</span>
WORKDIR /app

<span class="token comment"># 把安装依赖所需的 package.json AND package-lock.json 复制到 /app</span>
COPY package*.json ./
<span class="token comment"># 安装依赖</span>
RUN <span class="token function">npm</span> <span class="token function">install</span>
<span class="token comment"># 如果是生产环境使用 ci</span>
<span class="token comment"># RUN npm ci --omit=dev</span>

<span class="token comment"># 打包源码到 /app</span>
COPY <span class="token builtin class-name">.</span> <span class="token builtin class-name">.</span>

<span class="token comment"># 暴露端口 8989</span>
EXPOSE <span class="token number">8989</span>
<span class="token comment"># 启动容器后，执行 node server.js</span>
CMD <span class="token punctuation">[</span><span class="token string">&quot;node&quot;</span>, <span class="token string">&quot;server.js&quot;</span><span class="token punctuation">]</span>
</code></pre></div><ol start="3"><li>构建镜像 + 启动容器</li></ol> <blockquote><p>这一步跟上一个例子部署 Vite 项目一样~</p></blockquote> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">docker</span> build -t my-node-test <span class="token builtin class-name">.</span>  <span class="token comment"># 构建镜像</span>
<span class="token function">docker</span> run -d --name my-node-container -p <span class="token number">8995</span>:8989 my-node-test  <span class="token comment"># 启动容器</span>
</code></pre></div><ol start="4"><li>访问</li></ol> <p>之后浏览器通过 <code>http://localhost:8995/</code>就可以进行访问；也可通过<code>curl -i localhost:8995</code>查看网页连接情况：</p> <div class="language-sh extra-class"><pre class="language-sh"><code><span class="token function">curl</span> -i localhost:8995

HTTP/1.1 <span class="token number">200</span> OK
X-Powered-By: Express
Content-Type: text/html<span class="token punctuation">;</span> <span class="token assign-left variable">charset</span><span class="token operator">=</span>utf-8
Content-Length: <span class="token number">11</span>
ETag: W/<span class="token string">&quot;b-Ck1VqNd45QIvq3AZd8XYQLvEhtA&quot;</span>
Date: Sun, 06 Aug <span class="token number">2023</span> <span class="token number">17</span>:33:40 GMT
Connection: keep-alive
Keep-Alive: <span class="token assign-left variable">timeout</span><span class="token operator">=</span><span class="token number">5</span>

Hello World%  



<span class="token comment">### 其他命令</span>
<span class="token function">docker</span> stop my-node-container <span class="token comment"># 停止容器</span>
<span class="token function">docker</span> start my-node-container <span class="token comment"># 启动容器</span>
<span class="token function">docker</span> <span class="token builtin class-name">exec</span> -it my-node-container ash <span class="token comment"># 进入容器；因为使用 apline 版本的镜像，所以不能用 bash，这里用 sh 或者 ash 代替</span>
</code></pre></div><blockquote><p>后续也可以添加自动化部署~</p></blockquote> <h2 id="备注"><a href="#备注" class="header-anchor">#</a> 备注</h2> <h2 id="收藏"><a href="#收藏" class="header-anchor">#</a> 收藏</h2> <ul><li><p><a href="https://yeasy.gitbook.io/docker_practice/" target="_blank" rel="noopener noreferrer">Docker技术入门与实战<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li> <li><p><a href="https://juejin.cn/column/6965049243660714021" target="_blank" rel="noopener noreferrer">面向WEB开发人员的Docker<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li> <li><p>docker-compose版本信息：<a href="https://github.com/docker/compose/releases" target="_blank" rel="noopener noreferrer">https://github.com/docker/compose/releases<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p></li></ul> <h2 id="参考"><a href="#参考" class="header-anchor">#</a> 参考</h2> <ul><li><a href="https://juejin.cn/post/6844903918372143112" target="_blank" rel="noopener noreferrer">10分钟快速掌握Docker必备基础知识<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://juejin.cn/post/6844903591375814669" target="_blank" rel="noopener noreferrer">从 0 开始了解 Docker<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://juejin.cn/post/6844903815729119245" target="_blank" rel="noopener noreferrer">30 分钟快速入门 Docker 教程<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://juejin.cn/post/7139724794672447518" target="_blank" rel="noopener noreferrer">写给前端的 docker 使用指南<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://juejin.cn/post/7250029395023544376" target="_blank" rel="noopener noreferrer">前端工程师也应该了解的docker<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div></div> <!----> <div class="page-edit"><!----> <div class="tags"><a href="/blog/tags/?tag=docker" title="标签">#docker</a><a href="/blog/tags/?tag=%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2" title="标签">#自动化部署</a></div> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">9/25/2023, 2:44:16 AM</span></div></div> <div class="page-nav-wapper"><!----> <!----></div></div> <div class="article-list"><div class="article-title"><a href="/blog/archives" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/blog/more/github-actions.html"><div>
            Github Actions自动部署
            <!----></div></a> <span class="date">09-17</span></dt></dl><dl><dd>02</dd> <dt><a href="/blog/project/mono-react-project.html"><div>
            MonoRepo——React项目实践
            <!----></div></a> <span class="date">09-11</span></dt></dl><dl><dd>03</dd> <dt><a href="/blog/more/jenkins-deploy.html"><div>
            Jenkins前端自动化部署
            <!----></div></a> <span class="date">08-10</span></dt></dl> <dl><dd></dd> <dt><a href="/blog/archives" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><!----> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2021-2023
    <span>一苇 | <a href="https://beian.miit.gov.cn/" target="_blank" style="font-weight:normal"><img src="/blog/images/icp.png" width="20" height="20" alt="公网备案"/>京ICP备2021006935号-2</a> </span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"><!----><!----><!----><div></div></div></div>
    <script src="/blog/assets/js/app.07c9fec8.js" defer></script><script src="/blog/assets/js/3.a2a245ac.js" defer></script><script src="/blog/assets/js/71.de1aa836.js" defer></script><script src="/blog/assets/js/4.245b4373.js" defer></script>
  </body>
</html>
