---
title: JS算法
date: 2021-04-01 19:33:06
# permalink: null
article: false
categories: 
  - js
tags: 
  - 算法
permalink: false # 48d36a/
---



# JS算法

## 简介
> **算法（Algorithm）是指用来操作数据、解决程序问题的一组方法。** 对于同一个问题，使用不同的算法，也许最终得到的结果是一样的，但在过程中消耗的资源和时间却会有很大的区别。

算法主要从「时间」和「空间」两个维度去考量：
- 时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。
- 空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述。

### 时间复杂度
> 一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道；但没有必要对每个算法都上机测试，而且这种方式非常容易受运行环境的影响，在性能高的机器上跑出来的结果与在性能低的机器上跑的结果相差会很大。

一个算法中的语句执行次数称为语句频度或时间频度。记为`T(n)`。当n不断变化时，时间频度`T(n)`也会不断变化。但有时我们想知道它变化时呈现什么规律，为此我们引入**时间复杂度**的概念。


- **大O符号表示法**

大O符号表示法是一种更通用的用来体现时间复杂度的记法。在大O符号表示法中，时间复杂度的公式是： `T(n) = O( f(n) )`，其中`f(n)` 表示每行代码执行次数之和，而 `O` 表示正比例关系，这个公式的全称是：**算法的渐进时间复杂度。**

大O符号表示法并不是用于来真实代表算法的执行时间的，它是用来表示代码执行时间的增长变化趋势的。


常见的时间复杂度量级有：

- 常数阶`O(1)`
> 无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)，如:
``` js
int i = 1;
int j = 2;
++i;
j++;
int m = i + j;
```


- 线性阶`O(n)`
> for循环里面的代码会执行n遍，因此它消耗的时间是随着`n`的变化而变化的，因此这类代码都可以用`O(n)`来表示它的时间复杂度
``` js
for(i=1; i<=n; ++i)
{
   j = i;
   j++;
}
```

- 对数阶`O(logN)`
``` js
int i = 1;
while(i<n)
{
    i = i * 2;
}
```
> 从上面代码可以看到，在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。我们试着求解一下，假设循环x次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 `x = log2^n`

也就是说当循环 `log2^n` 次以后，这个代码就结束了。因此这个代码的时间复杂度为：O(logn)


- 线性对数阶`O(nlogN)`
> 线性对数阶`O(nlogN)` 其实非常容易理解，将时间复杂度为`O(logn)`的代码循环N遍的话，那么它的时间复杂度就是 `n * O(logN)`，也就是了`O(nlogN)`。
``` js
for(m=1; m<n; m++)
{
    i = 1;
    while(i<n)
    {
        i = i * 2;
    }
}
```


- 平方阶`O(n²)`
> 把 `O(n)` 的代码再嵌套循环一遍，它的时间复杂度就是 `O(n²)` 了。
``` js
for(x=1; x<=n; x++)
{
   for(i=1; i<=n; i++)
    {
       j = i;
       j++;
    }
}
```

- 立方阶`O(n³)`
> 参考上面的`O(n²)` 去理解就好了，`O(n³)`相当于三层n循环。


除了上述常见复杂度外，还有K次方阶`O(n^k)`、指数阶`(2^n)`、阶乘阶`O(n!)`、平方根阶`O(√n)`。

常用的时间复杂度按照耗费的时间从小到大依次是：

`O(1)<O(logn)<O(n)<O(nlogn)<O(n²)<O(n³)<O(2ⁿ)<O(n!)`




### 空间复杂度
> 空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，我们用 `S(n)` 来定义。

- 空间复杂度 `O(1)`
> 如果算法执行所需要的临时空间不随着某个变量n的大小而变化，即此算法空间复杂度为一个常量，可表示为 `O(1)`
``` js
int i = 1;
int j = 2;
++i;
j++;
int m = i + j;
```


- 空间复杂度 `O(n)`
``` js
int[] m = new int[n]
for(i=1; i<=n; ++i)
{
   j = i;
   j++;
}
```
这段代码中，第一行new了一个数组出来，这个数据占用的大小为n，这段代码的2-6行，虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即 S(n) = O(n)

> 参考：[算法的时间与空间复杂度（一看就懂）](https://zhuanlan.zhihu.com/p/50479555)、[算法（一）时间复杂度](https://blog.csdn.net/itachi85/article/details/54882603)



## 算法类型

### 暴力枚举


### 动态规划

DP


### 二分法


### 双指针



### 回溯


### 递归


### 并查集


## 排序

### 堆排序

### 计数排序


### 桶排序


### 拓扑排序

课程表

## 二叉树

DFS（Deep First Search）深度优先搜索、BFS（Breath First Search）广度优先搜索。



## 二进制


## 链表








## 算法网站

- [Leetcode算法](https://leetcode-cn.com/problemset/algorithms/)
- [牛客网题库](https://www.nowcoder.com/activity/oj)


## 收藏

- [leetcode最常见的150道前端面试题 --- 简单题上（44题）](https://juejin.cn/post/6987320619394138148)
- [【算法面试】leetcode最常见的150道前端面试题 --- 简单题下（44题）](https://juejin.cn/post/6989031479753834504)
- [66 道前端算法面试题附思路分析助你查漏补缺](https://mp.weixin.qq.com/s/6Xr4Af5_c8pSfmDRzNRCAw)
- [别再说你不懂Top K问题了](https://mp.weixin.qq.com/s/0_Rr6Pjshvd7Om2zTYMriQ)
- [前端进阶算法：常见算法题及完美题解](https://mp.weixin.qq.com/s/23fwxjhHag-WwLsS9Z9Caw)
- [前端笔试&面试爬坑系列---算法](https://juejin.cn/post/6844903656865677326)